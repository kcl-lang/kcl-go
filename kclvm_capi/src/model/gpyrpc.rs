// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gpyrpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.CmdArgSpec)
pub struct CmdArgSpec {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.CmdArgSpec.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CmdArgSpec.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.CmdArgSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CmdArgSpec {
    fn default() -> &'a CmdArgSpec {
        <CmdArgSpec as ::protobuf::Message>::default_instance()
    }
}

impl CmdArgSpec {
    pub fn new() -> CmdArgSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CmdArgSpec| { &m.name },
            |m: &mut CmdArgSpec| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &CmdArgSpec| { &m.value },
            |m: &mut CmdArgSpec| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CmdArgSpec>(
            "CmdArgSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CmdArgSpec {
    const NAME: &'static str = "CmdArgSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CmdArgSpec {
        CmdArgSpec::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CmdArgSpec {
        static instance: CmdArgSpec = CmdArgSpec {
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CmdArgSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CmdArgSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CmdArgSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CmdArgSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.CmdOverrideSpec)
pub struct CmdOverrideSpec {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.CmdOverrideSpec.pkgpath)
    pub pkgpath: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CmdOverrideSpec.field_path)
    pub field_path: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CmdOverrideSpec.field_value)
    pub field_value: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CmdOverrideSpec.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.CmdOverrideSpec.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CmdOverrideSpec {
    fn default() -> &'a CmdOverrideSpec {
        <CmdOverrideSpec as ::protobuf::Message>::default_instance()
    }
}

impl CmdOverrideSpec {
    pub fn new() -> CmdOverrideSpec {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pkgpath",
            |m: &CmdOverrideSpec| { &m.pkgpath },
            |m: &mut CmdOverrideSpec| { &mut m.pkgpath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field_path",
            |m: &CmdOverrideSpec| { &m.field_path },
            |m: &mut CmdOverrideSpec| { &mut m.field_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field_value",
            |m: &CmdOverrideSpec| { &m.field_value },
            |m: &mut CmdOverrideSpec| { &mut m.field_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &CmdOverrideSpec| { &m.action },
            |m: &mut CmdOverrideSpec| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CmdOverrideSpec>(
            "CmdOverrideSpec",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CmdOverrideSpec {
    const NAME: &'static str = "CmdOverrideSpec";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pkgpath = is.read_string()?;
                },
                18 => {
                    self.field_path = is.read_string()?;
                },
                26 => {
                    self.field_value = is.read_string()?;
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.pkgpath.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pkgpath);
        }
        if !self.field_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_path);
        }
        if !self.field_value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_value);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.pkgpath.is_empty() {
            os.write_string(1, &self.pkgpath)?;
        }
        if !self.field_path.is_empty() {
            os.write_string(2, &self.field_path)?;
        }
        if !self.field_value.is_empty() {
            os.write_string(3, &self.field_value)?;
        }
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CmdOverrideSpec {
        CmdOverrideSpec::new()
    }

    fn clear(&mut self) {
        self.pkgpath.clear();
        self.field_path.clear();
        self.field_value.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CmdOverrideSpec {
        static instance: CmdOverrideSpec = CmdOverrideSpec {
            pkgpath: ::std::string::String::new(),
            field_path: ::std::string::String::new(),
            field_value: ::std::string::String::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CmdOverrideSpec {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CmdOverrideSpec").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CmdOverrideSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CmdOverrideSpec {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.RestResponse)
pub struct RestResponse {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.RestResponse.result)
    pub result: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // @@protoc_insertion_point(field:gpyrpc.RestResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.RestResponse.kcl_err)
    pub kcl_err: ::protobuf::MessageField<KclError>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.RestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RestResponse {
    fn default() -> &'a RestResponse {
        <RestResponse as ::protobuf::Message>::default_instance()
    }
}

impl RestResponse {
    pub fn new() -> RestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "result",
            |m: &RestResponse| { &m.result },
            |m: &mut RestResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &RestResponse| { &m.error },
            |m: &mut RestResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KclError>(
            "kcl_err",
            |m: &RestResponse| { &m.kcl_err },
            |m: &mut RestResponse| { &mut m.kcl_err },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RestResponse>(
            "RestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RestResponse {
    const NAME: &'static str = "RestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.result)?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kcl_err)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if let Some(v) = self.kcl_err.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if let Some(v) = self.kcl_err.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RestResponse {
        RestResponse::new()
    }

    fn clear(&mut self) {
        self.result.clear();
        self.error.clear();
        self.kcl_err.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RestResponse {
        static instance: RestResponse = RestResponse {
            result: ::protobuf::MessageField::none(),
            error: ::std::string::String::new(),
            kcl_err: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.KclError)
pub struct KclError {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.KclError.ewcode)
    pub ewcode: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclError.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclError.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclError.error_infos)
    pub error_infos: ::std::vec::Vec<KclErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.KclError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KclError {
    fn default() -> &'a KclError {
        <KclError as ::protobuf::Message>::default_instance()
    }
}

impl KclError {
    pub fn new() -> KclError {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ewcode",
            |m: &KclError| { &m.ewcode },
            |m: &mut KclError| { &mut m.ewcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &KclError| { &m.name },
            |m: &mut KclError| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &KclError| { &m.msg },
            |m: &mut KclError| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "error_infos",
            |m: &KclError| { &m.error_infos },
            |m: &mut KclError| { &mut m.error_infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KclError>(
            "KclError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KclError {
    const NAME: &'static str = "KclError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ewcode = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.msg = is.read_string()?;
                },
                34 => {
                    self.error_infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ewcode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ewcode);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.msg);
        }
        for value in &self.error_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ewcode.is_empty() {
            os.write_string(1, &self.ewcode)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.msg.is_empty() {
            os.write_string(3, &self.msg)?;
        }
        for v in &self.error_infos {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KclError {
        KclError::new()
    }

    fn clear(&mut self) {
        self.ewcode.clear();
        self.name.clear();
        self.msg.clear();
        self.error_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KclError {
        static instance: KclError = KclError {
            ewcode: ::std::string::String::new(),
            name: ::std::string::String::new(),
            msg: ::std::string::String::new(),
            error_infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KclError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KclError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KclError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KclError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.KclErrorInfo)
pub struct KclErrorInfo {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.err_level)
    pub err_level: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.arg_msg)
    pub arg_msg: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.filename)
    pub filename: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.src_code)
    pub src_code: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.line_no)
    pub line_no: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclErrorInfo.col_no)
    pub col_no: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.KclErrorInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KclErrorInfo {
    fn default() -> &'a KclErrorInfo {
        <KclErrorInfo as ::protobuf::Message>::default_instance()
    }
}

impl KclErrorInfo {
    pub fn new() -> KclErrorInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "err_level",
            |m: &KclErrorInfo| { &m.err_level },
            |m: &mut KclErrorInfo| { &mut m.err_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "arg_msg",
            |m: &KclErrorInfo| { &m.arg_msg },
            |m: &mut KclErrorInfo| { &mut m.arg_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filename",
            |m: &KclErrorInfo| { &m.filename },
            |m: &mut KclErrorInfo| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "src_code",
            |m: &KclErrorInfo| { &m.src_code },
            |m: &mut KclErrorInfo| { &mut m.src_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "line_no",
            |m: &KclErrorInfo| { &m.line_no },
            |m: &mut KclErrorInfo| { &mut m.line_no },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "col_no",
            |m: &KclErrorInfo| { &m.col_no },
            |m: &mut KclErrorInfo| { &mut m.col_no },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KclErrorInfo>(
            "KclErrorInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KclErrorInfo {
    const NAME: &'static str = "KclErrorInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.err_level = is.read_string()?;
                },
                18 => {
                    self.arg_msg = is.read_string()?;
                },
                26 => {
                    self.filename = is.read_string()?;
                },
                34 => {
                    self.src_code = is.read_string()?;
                },
                42 => {
                    self.line_no = is.read_string()?;
                },
                50 => {
                    self.col_no = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.err_level.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.err_level);
        }
        if !self.arg_msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.arg_msg);
        }
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filename);
        }
        if !self.src_code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.src_code);
        }
        if !self.line_no.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.line_no);
        }
        if !self.col_no.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.col_no);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.err_level.is_empty() {
            os.write_string(1, &self.err_level)?;
        }
        if !self.arg_msg.is_empty() {
            os.write_string(2, &self.arg_msg)?;
        }
        if !self.filename.is_empty() {
            os.write_string(3, &self.filename)?;
        }
        if !self.src_code.is_empty() {
            os.write_string(4, &self.src_code)?;
        }
        if !self.line_no.is_empty() {
            os.write_string(5, &self.line_no)?;
        }
        if !self.col_no.is_empty() {
            os.write_string(6, &self.col_no)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KclErrorInfo {
        KclErrorInfo::new()
    }

    fn clear(&mut self) {
        self.err_level.clear();
        self.arg_msg.clear();
        self.filename.clear();
        self.src_code.clear();
        self.line_no.clear();
        self.col_no.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KclErrorInfo {
        static instance: KclErrorInfo = KclErrorInfo {
            err_level: ::std::string::String::new(),
            arg_msg: ::std::string::String::new(),
            filename: ::std::string::String::new(),
            src_code: ::std::string::String::new(),
            line_no: ::std::string::String::new(),
            col_no: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KclErrorInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KclErrorInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KclErrorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KclErrorInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Ping_Args)
pub struct Ping_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Ping_Args.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Ping_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ping_Args {
    fn default() -> &'a Ping_Args {
        <Ping_Args as ::protobuf::Message>::default_instance()
    }
}

impl Ping_Args {
    pub fn new() -> Ping_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Ping_Args| { &m.value },
            |m: &mut Ping_Args| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ping_Args>(
            "Ping_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ping_Args {
    const NAME: &'static str = "Ping_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ping_Args {
        Ping_Args::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ping_Args {
        static instance: Ping_Args = Ping_Args {
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ping_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ping_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ping_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Ping_Result)
pub struct Ping_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Ping_Result.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Ping_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ping_Result {
    fn default() -> &'a Ping_Result {
        <Ping_Result as ::protobuf::Message>::default_instance()
    }
}

impl Ping_Result {
    pub fn new() -> Ping_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Ping_Result| { &m.value },
            |m: &mut Ping_Result| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ping_Result>(
            "Ping_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ping_Result {
    const NAME: &'static str = "Ping_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ping_Result {
        Ping_Result::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ping_Result {
        static instance: Ping_Result = Ping_Result {
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ping_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ping_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ping_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListMethod_Args)
pub struct ListMethod_Args {
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListMethod_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListMethod_Args {
    fn default() -> &'a ListMethod_Args {
        <ListMethod_Args as ::protobuf::Message>::default_instance()
    }
}

impl ListMethod_Args {
    pub fn new() -> ListMethod_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListMethod_Args>(
            "ListMethod_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListMethod_Args {
    const NAME: &'static str = "ListMethod_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListMethod_Args {
        ListMethod_Args::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListMethod_Args {
        static instance: ListMethod_Args = ListMethod_Args {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListMethod_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListMethod_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListMethod_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMethod_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListMethod_Result)
pub struct ListMethod_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListMethod_Result.method_name_list)
    pub method_name_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListMethod_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListMethod_Result {
    fn default() -> &'a ListMethod_Result {
        <ListMethod_Result as ::protobuf::Message>::default_instance()
    }
}

impl ListMethod_Result {
    pub fn new() -> ListMethod_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "method_name_list",
            |m: &ListMethod_Result| { &m.method_name_list },
            |m: &mut ListMethod_Result| { &mut m.method_name_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListMethod_Result>(
            "ListMethod_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListMethod_Result {
    const NAME: &'static str = "ListMethod_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method_name_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.method_name_list {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.method_name_list {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListMethod_Result {
        ListMethod_Result::new()
    }

    fn clear(&mut self) {
        self.method_name_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListMethod_Result {
        static instance: ListMethod_Result = ListMethod_Result {
            method_name_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListMethod_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListMethod_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListMethod_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMethod_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseFile_LarkTree_Args)
pub struct ParseFile_LarkTree_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_LarkTree_Args.filename)
    pub filename: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_LarkTree_Args.source_code)
    pub source_code: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_LarkTree_Args.ignore_file_line)
    pub ignore_file_line: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseFile_LarkTree_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseFile_LarkTree_Args {
    fn default() -> &'a ParseFile_LarkTree_Args {
        <ParseFile_LarkTree_Args as ::protobuf::Message>::default_instance()
    }
}

impl ParseFile_LarkTree_Args {
    pub fn new() -> ParseFile_LarkTree_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filename",
            |m: &ParseFile_LarkTree_Args| { &m.filename },
            |m: &mut ParseFile_LarkTree_Args| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_code",
            |m: &ParseFile_LarkTree_Args| { &m.source_code },
            |m: &mut ParseFile_LarkTree_Args| { &mut m.source_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ignore_file_line",
            |m: &ParseFile_LarkTree_Args| { &m.ignore_file_line },
            |m: &mut ParseFile_LarkTree_Args| { &mut m.ignore_file_line },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseFile_LarkTree_Args>(
            "ParseFile_LarkTree_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseFile_LarkTree_Args {
    const NAME: &'static str = "ParseFile_LarkTree_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = is.read_string()?;
                },
                18 => {
                    self.source_code = is.read_string()?;
                },
                24 => {
                    self.ignore_file_line = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.filename);
        }
        if !self.source_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_code);
        }
        if self.ignore_file_line != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.filename.is_empty() {
            os.write_string(1, &self.filename)?;
        }
        if !self.source_code.is_empty() {
            os.write_string(2, &self.source_code)?;
        }
        if self.ignore_file_line != false {
            os.write_bool(3, self.ignore_file_line)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseFile_LarkTree_Args {
        ParseFile_LarkTree_Args::new()
    }

    fn clear(&mut self) {
        self.filename.clear();
        self.source_code.clear();
        self.ignore_file_line = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseFile_LarkTree_Args {
        static instance: ParseFile_LarkTree_Args = ParseFile_LarkTree_Args {
            filename: ::std::string::String::new(),
            source_code: ::std::string::String::new(),
            ignore_file_line: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseFile_LarkTree_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseFile_LarkTree_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseFile_LarkTree_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseFile_LarkTree_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseFile_LarkTree_Result)
pub struct ParseFile_LarkTree_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_LarkTree_Result.lark_tree_json)
    pub lark_tree_json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseFile_LarkTree_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseFile_LarkTree_Result {
    fn default() -> &'a ParseFile_LarkTree_Result {
        <ParseFile_LarkTree_Result as ::protobuf::Message>::default_instance()
    }
}

impl ParseFile_LarkTree_Result {
    pub fn new() -> ParseFile_LarkTree_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lark_tree_json",
            |m: &ParseFile_LarkTree_Result| { &m.lark_tree_json },
            |m: &mut ParseFile_LarkTree_Result| { &mut m.lark_tree_json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseFile_LarkTree_Result>(
            "ParseFile_LarkTree_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseFile_LarkTree_Result {
    const NAME: &'static str = "ParseFile_LarkTree_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lark_tree_json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.lark_tree_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lark_tree_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.lark_tree_json.is_empty() {
            os.write_string(1, &self.lark_tree_json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseFile_LarkTree_Result {
        ParseFile_LarkTree_Result::new()
    }

    fn clear(&mut self) {
        self.lark_tree_json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseFile_LarkTree_Result {
        static instance: ParseFile_LarkTree_Result = ParseFile_LarkTree_Result {
            lark_tree_json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseFile_LarkTree_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseFile_LarkTree_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseFile_LarkTree_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseFile_LarkTree_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseFile_AST_Args)
pub struct ParseFile_AST_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_AST_Args.filename)
    pub filename: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_AST_Args.source_code)
    pub source_code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseFile_AST_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseFile_AST_Args {
    fn default() -> &'a ParseFile_AST_Args {
        <ParseFile_AST_Args as ::protobuf::Message>::default_instance()
    }
}

impl ParseFile_AST_Args {
    pub fn new() -> ParseFile_AST_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filename",
            |m: &ParseFile_AST_Args| { &m.filename },
            |m: &mut ParseFile_AST_Args| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_code",
            |m: &ParseFile_AST_Args| { &m.source_code },
            |m: &mut ParseFile_AST_Args| { &mut m.source_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseFile_AST_Args>(
            "ParseFile_AST_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseFile_AST_Args {
    const NAME: &'static str = "ParseFile_AST_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = is.read_string()?;
                },
                18 => {
                    self.source_code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.filename);
        }
        if !self.source_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.filename.is_empty() {
            os.write_string(1, &self.filename)?;
        }
        if !self.source_code.is_empty() {
            os.write_string(2, &self.source_code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseFile_AST_Args {
        ParseFile_AST_Args::new()
    }

    fn clear(&mut self) {
        self.filename.clear();
        self.source_code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseFile_AST_Args {
        static instance: ParseFile_AST_Args = ParseFile_AST_Args {
            filename: ::std::string::String::new(),
            source_code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseFile_AST_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseFile_AST_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseFile_AST_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseFile_AST_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseFile_AST_Result)
pub struct ParseFile_AST_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseFile_AST_Result.ast_json)
    pub ast_json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseFile_AST_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseFile_AST_Result {
    fn default() -> &'a ParseFile_AST_Result {
        <ParseFile_AST_Result as ::protobuf::Message>::default_instance()
    }
}

impl ParseFile_AST_Result {
    pub fn new() -> ParseFile_AST_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ast_json",
            |m: &ParseFile_AST_Result| { &m.ast_json },
            |m: &mut ParseFile_AST_Result| { &mut m.ast_json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseFile_AST_Result>(
            "ParseFile_AST_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseFile_AST_Result {
    const NAME: &'static str = "ParseFile_AST_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ast_json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ast_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ast_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ast_json.is_empty() {
            os.write_string(1, &self.ast_json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseFile_AST_Result {
        ParseFile_AST_Result::new()
    }

    fn clear(&mut self) {
        self.ast_json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseFile_AST_Result {
        static instance: ParseFile_AST_Result = ParseFile_AST_Result {
            ast_json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseFile_AST_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseFile_AST_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseFile_AST_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseFile_AST_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseProgram_AST_Args)
pub struct ParseProgram_AST_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseProgram_AST_Args.k_filename_list)
    pub k_filename_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseProgram_AST_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseProgram_AST_Args {
    fn default() -> &'a ParseProgram_AST_Args {
        <ParseProgram_AST_Args as ::protobuf::Message>::default_instance()
    }
}

impl ParseProgram_AST_Args {
    pub fn new() -> ParseProgram_AST_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "k_filename_list",
            |m: &ParseProgram_AST_Args| { &m.k_filename_list },
            |m: &mut ParseProgram_AST_Args| { &mut m.k_filename_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseProgram_AST_Args>(
            "ParseProgram_AST_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseProgram_AST_Args {
    const NAME: &'static str = "ParseProgram_AST_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.k_filename_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.k_filename_list {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.k_filename_list {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseProgram_AST_Args {
        ParseProgram_AST_Args::new()
    }

    fn clear(&mut self) {
        self.k_filename_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseProgram_AST_Args {
        static instance: ParseProgram_AST_Args = ParseProgram_AST_Args {
            k_filename_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseProgram_AST_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseProgram_AST_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseProgram_AST_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseProgram_AST_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ParseProgram_AST_Result)
pub struct ParseProgram_AST_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ParseProgram_AST_Result.ast_json)
    pub ast_json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ParseProgram_AST_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ParseProgram_AST_Result {
    fn default() -> &'a ParseProgram_AST_Result {
        <ParseProgram_AST_Result as ::protobuf::Message>::default_instance()
    }
}

impl ParseProgram_AST_Result {
    pub fn new() -> ParseProgram_AST_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ast_json",
            |m: &ParseProgram_AST_Result| { &m.ast_json },
            |m: &mut ParseProgram_AST_Result| { &mut m.ast_json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParseProgram_AST_Result>(
            "ParseProgram_AST_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ParseProgram_AST_Result {
    const NAME: &'static str = "ParseProgram_AST_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ast_json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ast_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ast_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ast_json.is_empty() {
            os.write_string(1, &self.ast_json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ParseProgram_AST_Result {
        ParseProgram_AST_Result::new()
    }

    fn clear(&mut self) {
        self.ast_json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ParseProgram_AST_Result {
        static instance: ParseProgram_AST_Result = ParseProgram_AST_Result {
            ast_json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ParseProgram_AST_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ParseProgram_AST_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ParseProgram_AST_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParseProgram_AST_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ExecProgram_Args)
pub struct ExecProgram_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.work_dir)
    pub work_dir: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.k_filename_list)
    pub k_filename_list: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.k_code_list)
    pub k_code_list: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.args)
    pub args: ::std::vec::Vec<CmdArgSpec>,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.overrides)
    pub overrides: ::std::vec::Vec<CmdOverrideSpec>,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.disable_yaml_result)
    pub disable_yaml_result: bool,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.print_override_ast)
    pub print_override_ast: bool,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.strict_range_check)
    pub strict_range_check: bool,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.disable_none)
    pub disable_none: bool,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.verbose)
    pub verbose: i32,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.debug)
    pub debug: i32,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.sort_keys)
    pub sort_keys: bool,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Args.include_schema_type_path)
    pub include_schema_type_path: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ExecProgram_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecProgram_Args {
    fn default() -> &'a ExecProgram_Args {
        <ExecProgram_Args as ::protobuf::Message>::default_instance()
    }
}

impl ExecProgram_Args {
    pub fn new() -> ExecProgram_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_dir",
            |m: &ExecProgram_Args| { &m.work_dir },
            |m: &mut ExecProgram_Args| { &mut m.work_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "k_filename_list",
            |m: &ExecProgram_Args| { &m.k_filename_list },
            |m: &mut ExecProgram_Args| { &mut m.k_filename_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "k_code_list",
            |m: &ExecProgram_Args| { &m.k_code_list },
            |m: &mut ExecProgram_Args| { &mut m.k_code_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ExecProgram_Args| { &m.args },
            |m: &mut ExecProgram_Args| { &mut m.args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "overrides",
            |m: &ExecProgram_Args| { &m.overrides },
            |m: &mut ExecProgram_Args| { &mut m.overrides },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_yaml_result",
            |m: &ExecProgram_Args| { &m.disable_yaml_result },
            |m: &mut ExecProgram_Args| { &mut m.disable_yaml_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "print_override_ast",
            |m: &ExecProgram_Args| { &m.print_override_ast },
            |m: &mut ExecProgram_Args| { &mut m.print_override_ast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "strict_range_check",
            |m: &ExecProgram_Args| { &m.strict_range_check },
            |m: &mut ExecProgram_Args| { &mut m.strict_range_check },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_none",
            |m: &ExecProgram_Args| { &m.disable_none },
            |m: &mut ExecProgram_Args| { &mut m.disable_none },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verbose",
            |m: &ExecProgram_Args| { &m.verbose },
            |m: &mut ExecProgram_Args| { &mut m.verbose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "debug",
            |m: &ExecProgram_Args| { &m.debug },
            |m: &mut ExecProgram_Args| { &mut m.debug },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_keys",
            |m: &ExecProgram_Args| { &m.sort_keys },
            |m: &mut ExecProgram_Args| { &mut m.sort_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_schema_type_path",
            |m: &ExecProgram_Args| { &m.include_schema_type_path },
            |m: &mut ExecProgram_Args| { &mut m.include_schema_type_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecProgram_Args>(
            "ExecProgram_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecProgram_Args {
    const NAME: &'static str = "ExecProgram_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_dir = is.read_string()?;
                },
                18 => {
                    self.k_filename_list.push(is.read_string()?);
                },
                26 => {
                    self.k_code_list.push(is.read_string()?);
                },
                34 => {
                    self.args.push(is.read_message()?);
                },
                42 => {
                    self.overrides.push(is.read_message()?);
                },
                48 => {
                    self.disable_yaml_result = is.read_bool()?;
                },
                56 => {
                    self.print_override_ast = is.read_bool()?;
                },
                64 => {
                    self.strict_range_check = is.read_bool()?;
                },
                72 => {
                    self.disable_none = is.read_bool()?;
                },
                80 => {
                    self.verbose = is.read_int32()?;
                },
                88 => {
                    self.debug = is.read_int32()?;
                },
                96 => {
                    self.sort_keys = is.read_bool()?;
                },
                104 => {
                    self.include_schema_type_path = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_dir);
        }
        for value in &self.k_filename_list {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.k_code_list {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.overrides {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.disable_yaml_result != false {
            my_size += 1 + 1;
        }
        if self.print_override_ast != false {
            my_size += 1 + 1;
        }
        if self.strict_range_check != false {
            my_size += 1 + 1;
        }
        if self.disable_none != false {
            my_size += 1 + 1;
        }
        if self.verbose != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.verbose);
        }
        if self.debug != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.debug);
        }
        if self.sort_keys != false {
            my_size += 1 + 1;
        }
        if self.include_schema_type_path != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_dir.is_empty() {
            os.write_string(1, &self.work_dir)?;
        }
        for v in &self.k_filename_list {
            os.write_string(2, &v)?;
        };
        for v in &self.k_code_list {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.overrides {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.disable_yaml_result != false {
            os.write_bool(6, self.disable_yaml_result)?;
        }
        if self.print_override_ast != false {
            os.write_bool(7, self.print_override_ast)?;
        }
        if self.strict_range_check != false {
            os.write_bool(8, self.strict_range_check)?;
        }
        if self.disable_none != false {
            os.write_bool(9, self.disable_none)?;
        }
        if self.verbose != 0 {
            os.write_int32(10, self.verbose)?;
        }
        if self.debug != 0 {
            os.write_int32(11, self.debug)?;
        }
        if self.sort_keys != false {
            os.write_bool(12, self.sort_keys)?;
        }
        if self.include_schema_type_path != false {
            os.write_bool(13, self.include_schema_type_path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecProgram_Args {
        ExecProgram_Args::new()
    }

    fn clear(&mut self) {
        self.work_dir.clear();
        self.k_filename_list.clear();
        self.k_code_list.clear();
        self.args.clear();
        self.overrides.clear();
        self.disable_yaml_result = false;
        self.print_override_ast = false;
        self.strict_range_check = false;
        self.disable_none = false;
        self.verbose = 0;
        self.debug = 0;
        self.sort_keys = false;
        self.include_schema_type_path = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecProgram_Args {
        static instance: ExecProgram_Args = ExecProgram_Args {
            work_dir: ::std::string::String::new(),
            k_filename_list: ::std::vec::Vec::new(),
            k_code_list: ::std::vec::Vec::new(),
            args: ::std::vec::Vec::new(),
            overrides: ::std::vec::Vec::new(),
            disable_yaml_result: false,
            print_override_ast: false,
            strict_range_check: false,
            disable_none: false,
            verbose: 0,
            debug: 0,
            sort_keys: false,
            include_schema_type_path: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecProgram_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecProgram_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecProgram_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProgram_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ExecProgram_Result)
pub struct ExecProgram_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Result.json_result)
    pub json_result: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Result.yaml_result)
    pub yaml_result: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ExecProgram_Result.escaped_time)
    pub escaped_time: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ExecProgram_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecProgram_Result {
    fn default() -> &'a ExecProgram_Result {
        <ExecProgram_Result as ::protobuf::Message>::default_instance()
    }
}

impl ExecProgram_Result {
    pub fn new() -> ExecProgram_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json_result",
            |m: &ExecProgram_Result| { &m.json_result },
            |m: &mut ExecProgram_Result| { &mut m.json_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "yaml_result",
            |m: &ExecProgram_Result| { &m.yaml_result },
            |m: &mut ExecProgram_Result| { &mut m.yaml_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "escaped_time",
            |m: &ExecProgram_Result| { &m.escaped_time },
            |m: &mut ExecProgram_Result| { &mut m.escaped_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecProgram_Result>(
            "ExecProgram_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecProgram_Result {
    const NAME: &'static str = "ExecProgram_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.json_result = is.read_string()?;
                },
                18 => {
                    self.yaml_result = is.read_string()?;
                },
                810 => {
                    self.escaped_time = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.json_result.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.json_result);
        }
        if !self.yaml_result.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.yaml_result);
        }
        if !self.escaped_time.is_empty() {
            my_size += ::protobuf::rt::string_size(101, &self.escaped_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.json_result.is_empty() {
            os.write_string(1, &self.json_result)?;
        }
        if !self.yaml_result.is_empty() {
            os.write_string(2, &self.yaml_result)?;
        }
        if !self.escaped_time.is_empty() {
            os.write_string(101, &self.escaped_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecProgram_Result {
        ExecProgram_Result::new()
    }

    fn clear(&mut self) {
        self.json_result.clear();
        self.yaml_result.clear();
        self.escaped_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecProgram_Result {
        static instance: ExecProgram_Result = ExecProgram_Result {
            json_result: ::std::string::String::new(),
            yaml_result: ::std::string::String::new(),
            escaped_time: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecProgram_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecProgram_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecProgram_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProgram_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ResetPlugin_Args)
pub struct ResetPlugin_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ResetPlugin_Args.plugin_root)
    pub plugin_root: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ResetPlugin_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetPlugin_Args {
    fn default() -> &'a ResetPlugin_Args {
        <ResetPlugin_Args as ::protobuf::Message>::default_instance()
    }
}

impl ResetPlugin_Args {
    pub fn new() -> ResetPlugin_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plugin_root",
            |m: &ResetPlugin_Args| { &m.plugin_root },
            |m: &mut ResetPlugin_Args| { &mut m.plugin_root },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetPlugin_Args>(
            "ResetPlugin_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetPlugin_Args {
    const NAME: &'static str = "ResetPlugin_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plugin_root = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.plugin_root.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plugin_root);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.plugin_root.is_empty() {
            os.write_string(1, &self.plugin_root)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetPlugin_Args {
        ResetPlugin_Args::new()
    }

    fn clear(&mut self) {
        self.plugin_root.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetPlugin_Args {
        static instance: ResetPlugin_Args = ResetPlugin_Args {
            plugin_root: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResetPlugin_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetPlugin_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetPlugin_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPlugin_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ResetPlugin_Result)
pub struct ResetPlugin_Result {
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ResetPlugin_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetPlugin_Result {
    fn default() -> &'a ResetPlugin_Result {
        <ResetPlugin_Result as ::protobuf::Message>::default_instance()
    }
}

impl ResetPlugin_Result {
    pub fn new() -> ResetPlugin_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetPlugin_Result>(
            "ResetPlugin_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetPlugin_Result {
    const NAME: &'static str = "ResetPlugin_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetPlugin_Result {
        ResetPlugin_Result::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetPlugin_Result {
        static instance: ResetPlugin_Result = ResetPlugin_Result {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResetPlugin_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetPlugin_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetPlugin_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPlugin_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.FormatCode_Args)
pub struct FormatCode_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.FormatCode_Args.source)
    pub source: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.FormatCode_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FormatCode_Args {
    fn default() -> &'a FormatCode_Args {
        <FormatCode_Args as ::protobuf::Message>::default_instance()
    }
}

impl FormatCode_Args {
    pub fn new() -> FormatCode_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &FormatCode_Args| { &m.source },
            |m: &mut FormatCode_Args| { &mut m.source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatCode_Args>(
            "FormatCode_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FormatCode_Args {
    const NAME: &'static str = "FormatCode_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.source.is_empty() {
            os.write_string(1, &self.source)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FormatCode_Args {
        FormatCode_Args::new()
    }

    fn clear(&mut self) {
        self.source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FormatCode_Args {
        static instance: FormatCode_Args = FormatCode_Args {
            source: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FormatCode_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FormatCode_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FormatCode_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatCode_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.FormatCode_Result)
pub struct FormatCode_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.FormatCode_Result.formatted)
    pub formatted: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.FormatCode_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FormatCode_Result {
    fn default() -> &'a FormatCode_Result {
        <FormatCode_Result as ::protobuf::Message>::default_instance()
    }
}

impl FormatCode_Result {
    pub fn new() -> FormatCode_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "formatted",
            |m: &FormatCode_Result| { &m.formatted },
            |m: &mut FormatCode_Result| { &mut m.formatted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatCode_Result>(
            "FormatCode_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FormatCode_Result {
    const NAME: &'static str = "FormatCode_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.formatted = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.formatted.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.formatted);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.formatted.is_empty() {
            os.write_bytes(1, &self.formatted)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FormatCode_Result {
        FormatCode_Result::new()
    }

    fn clear(&mut self) {
        self.formatted.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FormatCode_Result {
        static instance: FormatCode_Result = FormatCode_Result {
            formatted: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FormatCode_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FormatCode_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FormatCode_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatCode_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.FormatPath_Args)
pub struct FormatPath_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.FormatPath_Args.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.FormatPath_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FormatPath_Args {
    fn default() -> &'a FormatPath_Args {
        <FormatPath_Args as ::protobuf::Message>::default_instance()
    }
}

impl FormatPath_Args {
    pub fn new() -> FormatPath_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &FormatPath_Args| { &m.path },
            |m: &mut FormatPath_Args| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatPath_Args>(
            "FormatPath_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FormatPath_Args {
    const NAME: &'static str = "FormatPath_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FormatPath_Args {
        FormatPath_Args::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FormatPath_Args {
        static instance: FormatPath_Args = FormatPath_Args {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FormatPath_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FormatPath_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FormatPath_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatPath_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.FormatPath_Result)
pub struct FormatPath_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.FormatPath_Result.changedPaths)
    pub changedPaths: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.FormatPath_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FormatPath_Result {
    fn default() -> &'a FormatPath_Result {
        <FormatPath_Result as ::protobuf::Message>::default_instance()
    }
}

impl FormatPath_Result {
    pub fn new() -> FormatPath_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changedPaths",
            |m: &FormatPath_Result| { &m.changedPaths },
            |m: &mut FormatPath_Result| { &mut m.changedPaths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatPath_Result>(
            "FormatPath_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FormatPath_Result {
    const NAME: &'static str = "FormatPath_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.changedPaths.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.changedPaths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.changedPaths {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FormatPath_Result {
        FormatPath_Result::new()
    }

    fn clear(&mut self) {
        self.changedPaths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FormatPath_Result {
        static instance: FormatPath_Result = FormatPath_Result {
            changedPaths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FormatPath_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FormatPath_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FormatPath_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatPath_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.LintPath_Args)
pub struct LintPath_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.LintPath_Args.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.LintPath_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LintPath_Args {
    fn default() -> &'a LintPath_Args {
        <LintPath_Args as ::protobuf::Message>::default_instance()
    }
}

impl LintPath_Args {
    pub fn new() -> LintPath_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &LintPath_Args| { &m.path },
            |m: &mut LintPath_Args| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LintPath_Args>(
            "LintPath_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LintPath_Args {
    const NAME: &'static str = "LintPath_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LintPath_Args {
        LintPath_Args::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LintPath_Args {
        static instance: LintPath_Args = LintPath_Args {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LintPath_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LintPath_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LintPath_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LintPath_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.LintPath_Result)
pub struct LintPath_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.LintPath_Result.results)
    pub results: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.LintPath_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LintPath_Result {
    fn default() -> &'a LintPath_Result {
        <LintPath_Result as ::protobuf::Message>::default_instance()
    }
}

impl LintPath_Result {
    pub fn new() -> LintPath_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &LintPath_Result| { &m.results },
            |m: &mut LintPath_Result| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LintPath_Result>(
            "LintPath_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LintPath_Result {
    const NAME: &'static str = "LintPath_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LintPath_Result {
        LintPath_Result::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LintPath_Result {
        static instance: LintPath_Result = LintPath_Result {
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LintPath_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LintPath_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LintPath_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LintPath_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.OverrideFile_Args)
pub struct OverrideFile_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.OverrideFile_Args.file)
    pub file: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.OverrideFile_Args.specs)
    pub specs: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.OverrideFile_Args.import_paths)
    pub import_paths: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.OverrideFile_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OverrideFile_Args {
    fn default() -> &'a OverrideFile_Args {
        <OverrideFile_Args as ::protobuf::Message>::default_instance()
    }
}

impl OverrideFile_Args {
    pub fn new() -> OverrideFile_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file",
            |m: &OverrideFile_Args| { &m.file },
            |m: &mut OverrideFile_Args| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "specs",
            |m: &OverrideFile_Args| { &m.specs },
            |m: &mut OverrideFile_Args| { &mut m.specs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "import_paths",
            |m: &OverrideFile_Args| { &m.import_paths },
            |m: &mut OverrideFile_Args| { &mut m.import_paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OverrideFile_Args>(
            "OverrideFile_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OverrideFile_Args {
    const NAME: &'static str = "OverrideFile_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = is.read_string()?;
                },
                18 => {
                    self.specs.push(is.read_string()?);
                },
                26 => {
                    self.import_paths.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        for value in &self.specs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.import_paths {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        for v in &self.specs {
            os.write_string(2, &v)?;
        };
        for v in &self.import_paths {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OverrideFile_Args {
        OverrideFile_Args::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.specs.clear();
        self.import_paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OverrideFile_Args {
        static instance: OverrideFile_Args = OverrideFile_Args {
            file: ::std::string::String::new(),
            specs: ::std::vec::Vec::new(),
            import_paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OverrideFile_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OverrideFile_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OverrideFile_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OverrideFile_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.OverrideFile_Result)
pub struct OverrideFile_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.OverrideFile_Result.result)
    pub result: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.OverrideFile_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OverrideFile_Result {
    fn default() -> &'a OverrideFile_Result {
        <OverrideFile_Result as ::protobuf::Message>::default_instance()
    }
}

impl OverrideFile_Result {
    pub fn new() -> OverrideFile_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &OverrideFile_Result| { &m.result },
            |m: &mut OverrideFile_Result| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OverrideFile_Result>(
            "OverrideFile_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OverrideFile_Result {
    const NAME: &'static str = "OverrideFile_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OverrideFile_Result {
        OverrideFile_Result::new()
    }

    fn clear(&mut self) {
        self.result = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OverrideFile_Result {
        static instance: OverrideFile_Result = OverrideFile_Result {
            result: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OverrideFile_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OverrideFile_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OverrideFile_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OverrideFile_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.EvalCode_Args)
pub struct EvalCode_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.EvalCode_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.EvalCode_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvalCode_Args {
    fn default() -> &'a EvalCode_Args {
        <EvalCode_Args as ::protobuf::Message>::default_instance()
    }
}

impl EvalCode_Args {
    pub fn new() -> EvalCode_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &EvalCode_Args| { &m.code },
            |m: &mut EvalCode_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvalCode_Args>(
            "EvalCode_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvalCode_Args {
    const NAME: &'static str = "EvalCode_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvalCode_Args {
        EvalCode_Args::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvalCode_Args {
        static instance: EvalCode_Args = EvalCode_Args {
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvalCode_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvalCode_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvalCode_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalCode_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.EvalCode_Result)
pub struct EvalCode_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.EvalCode_Result.json_result)
    pub json_result: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.EvalCode_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvalCode_Result {
    fn default() -> &'a EvalCode_Result {
        <EvalCode_Result as ::protobuf::Message>::default_instance()
    }
}

impl EvalCode_Result {
    pub fn new() -> EvalCode_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json_result",
            |m: &EvalCode_Result| { &m.json_result },
            |m: &mut EvalCode_Result| { &mut m.json_result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvalCode_Result>(
            "EvalCode_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvalCode_Result {
    const NAME: &'static str = "EvalCode_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.json_result = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.json_result.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.json_result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.json_result.is_empty() {
            os.write_string(2, &self.json_result)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvalCode_Result {
        EvalCode_Result::new()
    }

    fn clear(&mut self) {
        self.json_result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvalCode_Result {
        static instance: EvalCode_Result = EvalCode_Result {
            json_result: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvalCode_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvalCode_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvalCode_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalCode_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ResolveCode_Args)
pub struct ResolveCode_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ResolveCode_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ResolveCode_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveCode_Args {
    fn default() -> &'a ResolveCode_Args {
        <ResolveCode_Args as ::protobuf::Message>::default_instance()
    }
}

impl ResolveCode_Args {
    pub fn new() -> ResolveCode_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ResolveCode_Args| { &m.code },
            |m: &mut ResolveCode_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveCode_Args>(
            "ResolveCode_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveCode_Args {
    const NAME: &'static str = "ResolveCode_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveCode_Args {
        ResolveCode_Args::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveCode_Args {
        static instance: ResolveCode_Args = ResolveCode_Args {
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveCode_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveCode_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveCode_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveCode_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ResolveCode_Result)
pub struct ResolveCode_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ResolveCode_Result.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ResolveCode_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResolveCode_Result {
    fn default() -> &'a ResolveCode_Result {
        <ResolveCode_Result as ::protobuf::Message>::default_instance()
    }
}

impl ResolveCode_Result {
    pub fn new() -> ResolveCode_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &ResolveCode_Result| { &m.success },
            |m: &mut ResolveCode_Result| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResolveCode_Result>(
            "ResolveCode_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResolveCode_Result {
    const NAME: &'static str = "ResolveCode_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResolveCode_Result {
        ResolveCode_Result::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResolveCode_Result {
        static instance: ResolveCode_Result = ResolveCode_Result {
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResolveCode_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResolveCode_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResolveCode_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveCode_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.GetSchemaType_Args)
pub struct GetSchemaType_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.GetSchemaType_Args.file)
    pub file: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.GetSchemaType_Args.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.GetSchemaType_Args.schema_name)
    pub schema_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.GetSchemaType_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSchemaType_Args {
    fn default() -> &'a GetSchemaType_Args {
        <GetSchemaType_Args as ::protobuf::Message>::default_instance()
    }
}

impl GetSchemaType_Args {
    pub fn new() -> GetSchemaType_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file",
            |m: &GetSchemaType_Args| { &m.file },
            |m: &mut GetSchemaType_Args| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &GetSchemaType_Args| { &m.code },
            |m: &mut GetSchemaType_Args| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_name",
            |m: &GetSchemaType_Args| { &m.schema_name },
            |m: &mut GetSchemaType_Args| { &mut m.schema_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSchemaType_Args>(
            "GetSchemaType_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSchemaType_Args {
    const NAME: &'static str = "GetSchemaType_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = is.read_string()?;
                },
                18 => {
                    self.code = is.read_string()?;
                },
                26 => {
                    self.schema_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.code);
        }
        if !self.schema_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.schema_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if !self.code.is_empty() {
            os.write_string(2, &self.code)?;
        }
        if !self.schema_name.is_empty() {
            os.write_string(3, &self.schema_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSchemaType_Args {
        GetSchemaType_Args::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.code.clear();
        self.schema_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSchemaType_Args {
        static instance: GetSchemaType_Args = GetSchemaType_Args {
            file: ::std::string::String::new(),
            code: ::std::string::String::new(),
            schema_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSchemaType_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSchemaType_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSchemaType_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSchemaType_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.GetSchemaType_Result)
pub struct GetSchemaType_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.GetSchemaType_Result.schema_type_list)
    pub schema_type_list: ::std::vec::Vec<KclType>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.GetSchemaType_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSchemaType_Result {
    fn default() -> &'a GetSchemaType_Result {
        <GetSchemaType_Result as ::protobuf::Message>::default_instance()
    }
}

impl GetSchemaType_Result {
    pub fn new() -> GetSchemaType_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "schema_type_list",
            |m: &GetSchemaType_Result| { &m.schema_type_list },
            |m: &mut GetSchemaType_Result| { &mut m.schema_type_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSchemaType_Result>(
            "GetSchemaType_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSchemaType_Result {
    const NAME: &'static str = "GetSchemaType_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.schema_type_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.schema_type_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.schema_type_list {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSchemaType_Result {
        GetSchemaType_Result::new()
    }

    fn clear(&mut self) {
        self.schema_type_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSchemaType_Result {
        static instance: GetSchemaType_Result = GetSchemaType_Result {
            schema_type_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSchemaType_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSchemaType_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSchemaType_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSchemaType_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ValidateCode_Args)
pub struct ValidateCode_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Args.data)
    pub data: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Args.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Args.schema)
    pub schema: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Args.attribute_name)
    pub attribute_name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Args.format)
    pub format: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ValidateCode_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateCode_Args {
    fn default() -> &'a ValidateCode_Args {
        <ValidateCode_Args as ::protobuf::Message>::default_instance()
    }
}

impl ValidateCode_Args {
    pub fn new() -> ValidateCode_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ValidateCode_Args| { &m.data },
            |m: &mut ValidateCode_Args| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &ValidateCode_Args| { &m.code },
            |m: &mut ValidateCode_Args| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema",
            |m: &ValidateCode_Args| { &m.schema },
            |m: &mut ValidateCode_Args| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute_name",
            |m: &ValidateCode_Args| { &m.attribute_name },
            |m: &mut ValidateCode_Args| { &mut m.attribute_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &ValidateCode_Args| { &m.format },
            |m: &mut ValidateCode_Args| { &mut m.format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateCode_Args>(
            "ValidateCode_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateCode_Args {
    const NAME: &'static str = "ValidateCode_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_string()?;
                },
                18 => {
                    self.code = is.read_string()?;
                },
                26 => {
                    self.schema = is.read_string()?;
                },
                34 => {
                    self.attribute_name = is.read_string()?;
                },
                42 => {
                    self.format = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.code);
        }
        if !self.schema.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.schema);
        }
        if !self.attribute_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.attribute_name);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_string(1, &self.data)?;
        }
        if !self.code.is_empty() {
            os.write_string(2, &self.code)?;
        }
        if !self.schema.is_empty() {
            os.write_string(3, &self.schema)?;
        }
        if !self.attribute_name.is_empty() {
            os.write_string(4, &self.attribute_name)?;
        }
        if !self.format.is_empty() {
            os.write_string(5, &self.format)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateCode_Args {
        ValidateCode_Args::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.code.clear();
        self.schema.clear();
        self.attribute_name.clear();
        self.format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateCode_Args {
        static instance: ValidateCode_Args = ValidateCode_Args {
            data: ::std::string::String::new(),
            code: ::std::string::String::new(),
            schema: ::std::string::String::new(),
            attribute_name: ::std::string::String::new(),
            format: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateCode_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateCode_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateCode_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateCode_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ValidateCode_Result)
pub struct ValidateCode_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Result.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gpyrpc.ValidateCode_Result.err_message)
    pub err_message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ValidateCode_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateCode_Result {
    fn default() -> &'a ValidateCode_Result {
        <ValidateCode_Result as ::protobuf::Message>::default_instance()
    }
}

impl ValidateCode_Result {
    pub fn new() -> ValidateCode_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &ValidateCode_Result| { &m.success },
            |m: &mut ValidateCode_Result| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "err_message",
            |m: &ValidateCode_Result| { &m.err_message },
            |m: &mut ValidateCode_Result| { &mut m.err_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateCode_Result>(
            "ValidateCode_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateCode_Result {
    const NAME: &'static str = "ValidateCode_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                18 => {
                    self.err_message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if !self.err_message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.err_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.err_message.is_empty() {
            os.write_string(2, &self.err_message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateCode_Result {
        ValidateCode_Result::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.err_message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateCode_Result {
        static instance: ValidateCode_Result = ValidateCode_Result {
            success: false,
            err_message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateCode_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateCode_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateCode_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateCode_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.CodeSnippet)
pub struct CodeSnippet {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.CodeSnippet.schema)
    pub schema: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CodeSnippet.rule)
    pub rule: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.CodeSnippet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeSnippet {
    fn default() -> &'a CodeSnippet {
        <CodeSnippet as ::protobuf::Message>::default_instance()
    }
}

impl CodeSnippet {
    pub fn new() -> CodeSnippet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema",
            |m: &CodeSnippet| { &m.schema },
            |m: &mut CodeSnippet| { &mut m.schema },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rule",
            |m: &CodeSnippet| { &m.rule },
            |m: &mut CodeSnippet| { &mut m.rule },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeSnippet>(
            "CodeSnippet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CodeSnippet {
    const NAME: &'static str = "CodeSnippet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.schema = is.read_string()?;
                },
                18 => {
                    self.rule = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.schema.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.schema);
        }
        if !self.rule.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rule);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.schema.is_empty() {
            os.write_string(1, &self.schema)?;
        }
        if !self.rule.is_empty() {
            os.write_string(2, &self.rule)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeSnippet {
        CodeSnippet::new()
    }

    fn clear(&mut self) {
        self.schema.clear();
        self.rule.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeSnippet {
        static instance: CodeSnippet = CodeSnippet {
            schema: ::std::string::String::new(),
            rule: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CodeSnippet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeSnippet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeSnippet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeSnippet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.SpliceCode_Args)
pub struct SpliceCode_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.SpliceCode_Args.codeSnippets)
    pub codeSnippets: ::std::vec::Vec<CodeSnippet>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.SpliceCode_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpliceCode_Args {
    fn default() -> &'a SpliceCode_Args {
        <SpliceCode_Args as ::protobuf::Message>::default_instance()
    }
}

impl SpliceCode_Args {
    pub fn new() -> SpliceCode_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "codeSnippets",
            |m: &SpliceCode_Args| { &m.codeSnippets },
            |m: &mut SpliceCode_Args| { &mut m.codeSnippets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpliceCode_Args>(
            "SpliceCode_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpliceCode_Args {
    const NAME: &'static str = "SpliceCode_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.codeSnippets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.codeSnippets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.codeSnippets {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpliceCode_Args {
        SpliceCode_Args::new()
    }

    fn clear(&mut self) {
        self.codeSnippets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpliceCode_Args {
        static instance: SpliceCode_Args = SpliceCode_Args {
            codeSnippets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpliceCode_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpliceCode_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpliceCode_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpliceCode_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.SpliceCode_Result)
pub struct SpliceCode_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.SpliceCode_Result.spliceCode)
    pub spliceCode: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.SpliceCode_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpliceCode_Result {
    fn default() -> &'a SpliceCode_Result {
        <SpliceCode_Result as ::protobuf::Message>::default_instance()
    }
}

impl SpliceCode_Result {
    pub fn new() -> SpliceCode_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spliceCode",
            |m: &SpliceCode_Result| { &m.spliceCode },
            |m: &mut SpliceCode_Result| { &mut m.spliceCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpliceCode_Result>(
            "SpliceCode_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpliceCode_Result {
    const NAME: &'static str = "SpliceCode_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.spliceCode = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.spliceCode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.spliceCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.spliceCode.is_empty() {
            os.write_string(1, &self.spliceCode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpliceCode_Result {
        SpliceCode_Result::new()
    }

    fn clear(&mut self) {
        self.spliceCode.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpliceCode_Result {
        static instance: SpliceCode_Result = SpliceCode_Result {
            spliceCode: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpliceCode_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpliceCode_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpliceCode_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpliceCode_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Position)
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Position.line)
    pub line: i64,
    // @@protoc_insertion_point(field:gpyrpc.Position.column)
    pub column: i64,
    // @@protoc_insertion_point(field:gpyrpc.Position.filename)
    pub filename: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "line",
            |m: &Position| { &m.line },
            |m: &mut Position| { &mut m.line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "column",
            |m: &Position| { &m.column },
            |m: &mut Position| { &mut m.column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filename",
            |m: &Position| { &m.filename },
            |m: &mut Position| { &mut m.filename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.line = is.read_int64()?;
                },
                16 => {
                    self.column = is.read_int64()?;
                },
                26 => {
                    self.filename = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.line != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.line);
        }
        if self.column != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.column);
        }
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filename);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.line != 0 {
            os.write_int64(1, self.line)?;
        }
        if self.column != 0 {
            os.write_int64(2, self.column)?;
        }
        if !self.filename.is_empty() {
            os.write_string(3, &self.filename)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.line = 0;
        self.column = 0;
        self.filename.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            line: 0,
            column: 0,
            filename: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Complete_Args)
pub struct Complete_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Complete_Args.pos)
    pub pos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:gpyrpc.Complete_Args.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.Complete_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Complete_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Complete_Args {
    fn default() -> &'a Complete_Args {
        <Complete_Args as ::protobuf::Message>::default_instance()
    }
}

impl Complete_Args {
    pub fn new() -> Complete_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "pos",
            |m: &Complete_Args| { &m.pos },
            |m: &mut Complete_Args| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Complete_Args| { &m.name },
            |m: &mut Complete_Args| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Complete_Args| { &m.code },
            |m: &mut Complete_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Complete_Args>(
            "Complete_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Complete_Args {
    const NAME: &'static str = "Complete_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.code.is_empty() {
            os.write_string(3, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Complete_Args {
        Complete_Args::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.name.clear();
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Complete_Args {
        static instance: Complete_Args = Complete_Args {
            pos: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Complete_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Complete_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Complete_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Complete_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Complete_Result)
pub struct Complete_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Complete_Result.completeItems)
    pub completeItems: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Complete_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Complete_Result {
    fn default() -> &'a Complete_Result {
        <Complete_Result as ::protobuf::Message>::default_instance()
    }
}

impl Complete_Result {
    pub fn new() -> Complete_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completeItems",
            |m: &Complete_Result| { &m.completeItems },
            |m: &mut Complete_Result| { &mut m.completeItems },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Complete_Result>(
            "Complete_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Complete_Result {
    const NAME: &'static str = "Complete_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.completeItems = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.completeItems.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.completeItems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.completeItems.is_empty() {
            os.write_string(1, &self.completeItems)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Complete_Result {
        Complete_Result::new()
    }

    fn clear(&mut self) {
        self.completeItems.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Complete_Result {
        static instance: Complete_Result = Complete_Result {
            completeItems: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Complete_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Complete_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Complete_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Complete_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.GoToDef_Args)
pub struct GoToDef_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.GoToDef_Args.pos)
    pub pos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:gpyrpc.GoToDef_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.GoToDef_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GoToDef_Args {
    fn default() -> &'a GoToDef_Args {
        <GoToDef_Args as ::protobuf::Message>::default_instance()
    }
}

impl GoToDef_Args {
    pub fn new() -> GoToDef_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "pos",
            |m: &GoToDef_Args| { &m.pos },
            |m: &mut GoToDef_Args| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &GoToDef_Args| { &m.code },
            |m: &mut GoToDef_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoToDef_Args>(
            "GoToDef_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GoToDef_Args {
    const NAME: &'static str = "GoToDef_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.code.is_empty() {
            os.write_string(2, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GoToDef_Args {
        GoToDef_Args::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GoToDef_Args {
        static instance: GoToDef_Args = GoToDef_Args {
            pos: ::protobuf::MessageField::none(),
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GoToDef_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GoToDef_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GoToDef_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoToDef_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.GoToDef_Result)
pub struct GoToDef_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.GoToDef_Result.locations)
    pub locations: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.GoToDef_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GoToDef_Result {
    fn default() -> &'a GoToDef_Result {
        <GoToDef_Result as ::protobuf::Message>::default_instance()
    }
}

impl GoToDef_Result {
    pub fn new() -> GoToDef_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "locations",
            |m: &GoToDef_Result| { &m.locations },
            |m: &mut GoToDef_Result| { &mut m.locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoToDef_Result>(
            "GoToDef_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GoToDef_Result {
    const NAME: &'static str = "GoToDef_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locations = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.locations.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.locations);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.locations.is_empty() {
            os.write_string(1, &self.locations)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GoToDef_Result {
        GoToDef_Result::new()
    }

    fn clear(&mut self) {
        self.locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GoToDef_Result {
        static instance: GoToDef_Result = GoToDef_Result {
            locations: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GoToDef_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GoToDef_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GoToDef_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoToDef_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.DocumentSymbol_Args)
pub struct DocumentSymbol_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.DocumentSymbol_Args.file)
    pub file: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.DocumentSymbol_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.DocumentSymbol_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DocumentSymbol_Args {
    fn default() -> &'a DocumentSymbol_Args {
        <DocumentSymbol_Args as ::protobuf::Message>::default_instance()
    }
}

impl DocumentSymbol_Args {
    pub fn new() -> DocumentSymbol_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file",
            |m: &DocumentSymbol_Args| { &m.file },
            |m: &mut DocumentSymbol_Args| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &DocumentSymbol_Args| { &m.code },
            |m: &mut DocumentSymbol_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DocumentSymbol_Args>(
            "DocumentSymbol_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DocumentSymbol_Args {
    const NAME: &'static str = "DocumentSymbol_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = is.read_string()?;
                },
                18 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if !self.code.is_empty() {
            os.write_string(2, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DocumentSymbol_Args {
        DocumentSymbol_Args::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DocumentSymbol_Args {
        static instance: DocumentSymbol_Args = DocumentSymbol_Args {
            file: ::std::string::String::new(),
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DocumentSymbol_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DocumentSymbol_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DocumentSymbol_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentSymbol_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.DocumentSymbol_Result)
pub struct DocumentSymbol_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.DocumentSymbol_Result.symbol)
    pub symbol: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.DocumentSymbol_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DocumentSymbol_Result {
    fn default() -> &'a DocumentSymbol_Result {
        <DocumentSymbol_Result as ::protobuf::Message>::default_instance()
    }
}

impl DocumentSymbol_Result {
    pub fn new() -> DocumentSymbol_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symbol",
            |m: &DocumentSymbol_Result| { &m.symbol },
            |m: &mut DocumentSymbol_Result| { &mut m.symbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DocumentSymbol_Result>(
            "DocumentSymbol_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DocumentSymbol_Result {
    const NAME: &'static str = "DocumentSymbol_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.symbol = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symbol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.symbol.is_empty() {
            os.write_string(1, &self.symbol)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DocumentSymbol_Result {
        DocumentSymbol_Result::new()
    }

    fn clear(&mut self) {
        self.symbol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DocumentSymbol_Result {
        static instance: DocumentSymbol_Result = DocumentSymbol_Result {
            symbol: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DocumentSymbol_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DocumentSymbol_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DocumentSymbol_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentSymbol_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Hover_Args)
pub struct Hover_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Hover_Args.pos)
    pub pos: ::protobuf::MessageField<Position>,
    // @@protoc_insertion_point(field:gpyrpc.Hover_Args.code)
    pub code: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Hover_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hover_Args {
    fn default() -> &'a Hover_Args {
        <Hover_Args as ::protobuf::Message>::default_instance()
    }
}

impl Hover_Args {
    pub fn new() -> Hover_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Position>(
            "pos",
            |m: &Hover_Args| { &m.pos },
            |m: &mut Hover_Args| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Hover_Args| { &m.code },
            |m: &mut Hover_Args| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hover_Args>(
            "Hover_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hover_Args {
    const NAME: &'static str = "Hover_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.code.is_empty() {
            os.write_string(2, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hover_Args {
        Hover_Args::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hover_Args {
        static instance: Hover_Args = Hover_Args {
            pos: ::protobuf::MessageField::none(),
            code: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hover_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hover_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hover_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hover_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Hover_Result)
pub struct Hover_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Hover_Result.hoverResult)
    pub hoverResult: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Hover_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hover_Result {
    fn default() -> &'a Hover_Result {
        <Hover_Result as ::protobuf::Message>::default_instance()
    }
}

impl Hover_Result {
    pub fn new() -> Hover_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hoverResult",
            |m: &Hover_Result| { &m.hoverResult },
            |m: &mut Hover_Result| { &mut m.hoverResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hover_Result>(
            "Hover_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hover_Result {
    const NAME: &'static str = "Hover_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hoverResult = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hoverResult.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hoverResult);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hoverResult.is_empty() {
            os.write_string(1, &self.hoverResult)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hover_Result {
        Hover_Result::new()
    }

    fn clear(&mut self) {
        self.hoverResult.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hover_Result {
        static instance: Hover_Result = Hover_Result {
            hoverResult: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hover_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hover_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hover_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hover_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListDepFiles_Args)
pub struct ListDepFiles_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Args.work_dir)
    pub work_dir: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Args.use_abs_path)
    pub use_abs_path: bool,
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Args.include_all)
    pub include_all: bool,
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Args.use_fast_parser)
    pub use_fast_parser: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListDepFiles_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDepFiles_Args {
    fn default() -> &'a ListDepFiles_Args {
        <ListDepFiles_Args as ::protobuf::Message>::default_instance()
    }
}

impl ListDepFiles_Args {
    pub fn new() -> ListDepFiles_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_dir",
            |m: &ListDepFiles_Args| { &m.work_dir },
            |m: &mut ListDepFiles_Args| { &mut m.work_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_abs_path",
            |m: &ListDepFiles_Args| { &m.use_abs_path },
            |m: &mut ListDepFiles_Args| { &mut m.use_abs_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_all",
            |m: &ListDepFiles_Args| { &m.include_all },
            |m: &mut ListDepFiles_Args| { &mut m.include_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_fast_parser",
            |m: &ListDepFiles_Args| { &m.use_fast_parser },
            |m: &mut ListDepFiles_Args| { &mut m.use_fast_parser },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDepFiles_Args>(
            "ListDepFiles_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDepFiles_Args {
    const NAME: &'static str = "ListDepFiles_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_dir = is.read_string()?;
                },
                16 => {
                    self.use_abs_path = is.read_bool()?;
                },
                24 => {
                    self.include_all = is.read_bool()?;
                },
                32 => {
                    self.use_fast_parser = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_dir);
        }
        if self.use_abs_path != false {
            my_size += 1 + 1;
        }
        if self.include_all != false {
            my_size += 1 + 1;
        }
        if self.use_fast_parser != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_dir.is_empty() {
            os.write_string(1, &self.work_dir)?;
        }
        if self.use_abs_path != false {
            os.write_bool(2, self.use_abs_path)?;
        }
        if self.include_all != false {
            os.write_bool(3, self.include_all)?;
        }
        if self.use_fast_parser != false {
            os.write_bool(4, self.use_fast_parser)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDepFiles_Args {
        ListDepFiles_Args::new()
    }

    fn clear(&mut self) {
        self.work_dir.clear();
        self.use_abs_path = false;
        self.include_all = false;
        self.use_fast_parser = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDepFiles_Args {
        static instance: ListDepFiles_Args = ListDepFiles_Args {
            work_dir: ::std::string::String::new(),
            use_abs_path: false,
            include_all: false,
            use_fast_parser: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDepFiles_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDepFiles_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDepFiles_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDepFiles_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListDepFiles_Result)
pub struct ListDepFiles_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Result.pkgroot)
    pub pkgroot: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Result.pkgpath)
    pub pkgpath: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ListDepFiles_Result.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListDepFiles_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDepFiles_Result {
    fn default() -> &'a ListDepFiles_Result {
        <ListDepFiles_Result as ::protobuf::Message>::default_instance()
    }
}

impl ListDepFiles_Result {
    pub fn new() -> ListDepFiles_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pkgroot",
            |m: &ListDepFiles_Result| { &m.pkgroot },
            |m: &mut ListDepFiles_Result| { &mut m.pkgroot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pkgpath",
            |m: &ListDepFiles_Result| { &m.pkgpath },
            |m: &mut ListDepFiles_Result| { &mut m.pkgpath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ListDepFiles_Result| { &m.files },
            |m: &mut ListDepFiles_Result| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDepFiles_Result>(
            "ListDepFiles_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDepFiles_Result {
    const NAME: &'static str = "ListDepFiles_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pkgroot = is.read_string()?;
                },
                18 => {
                    self.pkgpath = is.read_string()?;
                },
                26 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.pkgroot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pkgroot);
        }
        if !self.pkgpath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pkgpath);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.pkgroot.is_empty() {
            os.write_string(1, &self.pkgroot)?;
        }
        if !self.pkgpath.is_empty() {
            os.write_string(2, &self.pkgpath)?;
        }
        for v in &self.files {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDepFiles_Result {
        ListDepFiles_Result::new()
    }

    fn clear(&mut self) {
        self.pkgroot.clear();
        self.pkgpath.clear();
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDepFiles_Result {
        static instance: ListDepFiles_Result = ListDepFiles_Result {
            pkgroot: ::std::string::String::new(),
            pkgpath: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDepFiles_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDepFiles_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDepFiles_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDepFiles_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListUpStreamFiles_Args)
pub struct ListUpStreamFiles_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListUpStreamFiles_Args.work_dir)
    pub work_dir: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ListUpStreamFiles_Args.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListUpStreamFiles_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUpStreamFiles_Args {
    fn default() -> &'a ListUpStreamFiles_Args {
        <ListUpStreamFiles_Args as ::protobuf::Message>::default_instance()
    }
}

impl ListUpStreamFiles_Args {
    pub fn new() -> ListUpStreamFiles_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_dir",
            |m: &ListUpStreamFiles_Args| { &m.work_dir },
            |m: &mut ListUpStreamFiles_Args| { &mut m.work_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ListUpStreamFiles_Args| { &m.files },
            |m: &mut ListUpStreamFiles_Args| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUpStreamFiles_Args>(
            "ListUpStreamFiles_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUpStreamFiles_Args {
    const NAME: &'static str = "ListUpStreamFiles_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_dir = is.read_string()?;
                },
                18 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_dir);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_dir.is_empty() {
            os.write_string(1, &self.work_dir)?;
        }
        for v in &self.files {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUpStreamFiles_Args {
        ListUpStreamFiles_Args::new()
    }

    fn clear(&mut self) {
        self.work_dir.clear();
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUpStreamFiles_Args {
        static instance: ListUpStreamFiles_Args = ListUpStreamFiles_Args {
            work_dir: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUpStreamFiles_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUpStreamFiles_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUpStreamFiles_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUpStreamFiles_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListUpStreamFiles_Result)
pub struct ListUpStreamFiles_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListUpStreamFiles_Result.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListUpStreamFiles_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUpStreamFiles_Result {
    fn default() -> &'a ListUpStreamFiles_Result {
        <ListUpStreamFiles_Result as ::protobuf::Message>::default_instance()
    }
}

impl ListUpStreamFiles_Result {
    pub fn new() -> ListUpStreamFiles_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ListUpStreamFiles_Result| { &m.files },
            |m: &mut ListUpStreamFiles_Result| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUpStreamFiles_Result>(
            "ListUpStreamFiles_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUpStreamFiles_Result {
    const NAME: &'static str = "ListUpStreamFiles_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUpStreamFiles_Result {
        ListUpStreamFiles_Result::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUpStreamFiles_Result {
        static instance: ListUpStreamFiles_Result = ListUpStreamFiles_Result {
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUpStreamFiles_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUpStreamFiles_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUpStreamFiles_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUpStreamFiles_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListDownStreamFiles_Args)
pub struct ListDownStreamFiles_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListDownStreamFiles_Args.work_dir)
    pub work_dir: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.ListDownStreamFiles_Args.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.ListDownStreamFiles_Args.changed_paths)
    pub changed_paths: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListDownStreamFiles_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDownStreamFiles_Args {
    fn default() -> &'a ListDownStreamFiles_Args {
        <ListDownStreamFiles_Args as ::protobuf::Message>::default_instance()
    }
}

impl ListDownStreamFiles_Args {
    pub fn new() -> ListDownStreamFiles_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_dir",
            |m: &ListDownStreamFiles_Args| { &m.work_dir },
            |m: &mut ListDownStreamFiles_Args| { &mut m.work_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ListDownStreamFiles_Args| { &m.files },
            |m: &mut ListDownStreamFiles_Args| { &mut m.files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changed_paths",
            |m: &ListDownStreamFiles_Args| { &m.changed_paths },
            |m: &mut ListDownStreamFiles_Args| { &mut m.changed_paths },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDownStreamFiles_Args>(
            "ListDownStreamFiles_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDownStreamFiles_Args {
    const NAME: &'static str = "ListDownStreamFiles_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_dir = is.read_string()?;
                },
                18 => {
                    self.files.push(is.read_string()?);
                },
                26 => {
                    self.changed_paths.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_dir);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.changed_paths {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_dir.is_empty() {
            os.write_string(1, &self.work_dir)?;
        }
        for v in &self.files {
            os.write_string(2, &v)?;
        };
        for v in &self.changed_paths {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDownStreamFiles_Args {
        ListDownStreamFiles_Args::new()
    }

    fn clear(&mut self) {
        self.work_dir.clear();
        self.files.clear();
        self.changed_paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDownStreamFiles_Args {
        static instance: ListDownStreamFiles_Args = ListDownStreamFiles_Args {
            work_dir: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            changed_paths: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDownStreamFiles_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDownStreamFiles_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDownStreamFiles_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDownStreamFiles_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.ListDownStreamFiles_Result)
pub struct ListDownStreamFiles_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.ListDownStreamFiles_Result.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.ListDownStreamFiles_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDownStreamFiles_Result {
    fn default() -> &'a ListDownStreamFiles_Result {
        <ListDownStreamFiles_Result as ::protobuf::Message>::default_instance()
    }
}

impl ListDownStreamFiles_Result {
    pub fn new() -> ListDownStreamFiles_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &ListDownStreamFiles_Result| { &m.files },
            |m: &mut ListDownStreamFiles_Result| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDownStreamFiles_Result>(
            "ListDownStreamFiles_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDownStreamFiles_Result {
    const NAME: &'static str = "ListDownStreamFiles_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDownStreamFiles_Result {
        ListDownStreamFiles_Result::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDownStreamFiles_Result {
        static instance: ListDownStreamFiles_Result = ListDownStreamFiles_Result {
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDownStreamFiles_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDownStreamFiles_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDownStreamFiles_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDownStreamFiles_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.LoadSettingsFiles_Args)
pub struct LoadSettingsFiles_Args {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.LoadSettingsFiles_Args.work_dir)
    pub work_dir: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.LoadSettingsFiles_Args.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.LoadSettingsFiles_Args.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadSettingsFiles_Args {
    fn default() -> &'a LoadSettingsFiles_Args {
        <LoadSettingsFiles_Args as ::protobuf::Message>::default_instance()
    }
}

impl LoadSettingsFiles_Args {
    pub fn new() -> LoadSettingsFiles_Args {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "work_dir",
            |m: &LoadSettingsFiles_Args| { &m.work_dir },
            |m: &mut LoadSettingsFiles_Args| { &mut m.work_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &LoadSettingsFiles_Args| { &m.files },
            |m: &mut LoadSettingsFiles_Args| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadSettingsFiles_Args>(
            "LoadSettingsFiles_Args",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadSettingsFiles_Args {
    const NAME: &'static str = "LoadSettingsFiles_Args";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.work_dir = is.read_string()?;
                },
                18 => {
                    self.files.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.work_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work_dir);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.work_dir.is_empty() {
            os.write_string(1, &self.work_dir)?;
        }
        for v in &self.files {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadSettingsFiles_Args {
        LoadSettingsFiles_Args::new()
    }

    fn clear(&mut self) {
        self.work_dir.clear();
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadSettingsFiles_Args {
        static instance: LoadSettingsFiles_Args = LoadSettingsFiles_Args {
            work_dir: ::std::string::String::new(),
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadSettingsFiles_Args {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadSettingsFiles_Args").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadSettingsFiles_Args {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadSettingsFiles_Args {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.LoadSettingsFiles_Result)
pub struct LoadSettingsFiles_Result {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.LoadSettingsFiles_Result.kcl_cli_configs)
    pub kcl_cli_configs: ::protobuf::MessageField<CliConfig>,
    // @@protoc_insertion_point(field:gpyrpc.LoadSettingsFiles_Result.kcl_options)
    pub kcl_options: ::std::vec::Vec<KeyValuePair>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.LoadSettingsFiles_Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadSettingsFiles_Result {
    fn default() -> &'a LoadSettingsFiles_Result {
        <LoadSettingsFiles_Result as ::protobuf::Message>::default_instance()
    }
}

impl LoadSettingsFiles_Result {
    pub fn new() -> LoadSettingsFiles_Result {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CliConfig>(
            "kcl_cli_configs",
            |m: &LoadSettingsFiles_Result| { &m.kcl_cli_configs },
            |m: &mut LoadSettingsFiles_Result| { &mut m.kcl_cli_configs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kcl_options",
            |m: &LoadSettingsFiles_Result| { &m.kcl_options },
            |m: &mut LoadSettingsFiles_Result| { &mut m.kcl_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadSettingsFiles_Result>(
            "LoadSettingsFiles_Result",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadSettingsFiles_Result {
    const NAME: &'static str = "LoadSettingsFiles_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kcl_cli_configs)?;
                },
                18 => {
                    self.kcl_options.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kcl_cli_configs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.kcl_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.kcl_cli_configs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.kcl_options {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadSettingsFiles_Result {
        LoadSettingsFiles_Result::new()
    }

    fn clear(&mut self) {
        self.kcl_cli_configs.clear();
        self.kcl_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadSettingsFiles_Result {
        static instance: LoadSettingsFiles_Result = LoadSettingsFiles_Result {
            kcl_cli_configs: ::protobuf::MessageField::none(),
            kcl_options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadSettingsFiles_Result {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadSettingsFiles_Result").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadSettingsFiles_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadSettingsFiles_Result {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.CliConfig)
pub struct CliConfig {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.files)
    pub files: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.output)
    pub output: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.overrides)
    pub overrides: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.path_selector)
    pub path_selector: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.strict_range_check)
    pub strict_range_check: bool,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.disable_none)
    pub disable_none: bool,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.verbose)
    pub verbose: i64,
    // @@protoc_insertion_point(field:gpyrpc.CliConfig.debug)
    pub debug: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.CliConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CliConfig {
    fn default() -> &'a CliConfig {
        <CliConfig as ::protobuf::Message>::default_instance()
    }
}

impl CliConfig {
    pub fn new() -> CliConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &CliConfig| { &m.files },
            |m: &mut CliConfig| { &mut m.files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &CliConfig| { &m.output },
            |m: &mut CliConfig| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "overrides",
            |m: &CliConfig| { &m.overrides },
            |m: &mut CliConfig| { &mut m.overrides },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "path_selector",
            |m: &CliConfig| { &m.path_selector },
            |m: &mut CliConfig| { &mut m.path_selector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "strict_range_check",
            |m: &CliConfig| { &m.strict_range_check },
            |m: &mut CliConfig| { &mut m.strict_range_check },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_none",
            |m: &CliConfig| { &m.disable_none },
            |m: &mut CliConfig| { &mut m.disable_none },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verbose",
            |m: &CliConfig| { &m.verbose },
            |m: &mut CliConfig| { &mut m.verbose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "debug",
            |m: &CliConfig| { &m.debug },
            |m: &mut CliConfig| { &mut m.debug },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CliConfig>(
            "CliConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CliConfig {
    const NAME: &'static str = "CliConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files.push(is.read_string()?);
                },
                18 => {
                    self.output = is.read_string()?;
                },
                26 => {
                    self.overrides.push(is.read_string()?);
                },
                34 => {
                    self.path_selector.push(is.read_string()?);
                },
                40 => {
                    self.strict_range_check = is.read_bool()?;
                },
                48 => {
                    self.disable_none = is.read_bool()?;
                },
                56 => {
                    self.verbose = is.read_int64()?;
                },
                64 => {
                    self.debug = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.output);
        }
        for value in &self.overrides {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.path_selector {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.strict_range_check != false {
            my_size += 1 + 1;
        }
        if self.disable_none != false {
            my_size += 1 + 1;
        }
        if self.verbose != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.verbose);
        }
        if self.debug != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files {
            os.write_string(1, &v)?;
        };
        if !self.output.is_empty() {
            os.write_string(2, &self.output)?;
        }
        for v in &self.overrides {
            os.write_string(3, &v)?;
        };
        for v in &self.path_selector {
            os.write_string(4, &v)?;
        };
        if self.strict_range_check != false {
            os.write_bool(5, self.strict_range_check)?;
        }
        if self.disable_none != false {
            os.write_bool(6, self.disable_none)?;
        }
        if self.verbose != 0 {
            os.write_int64(7, self.verbose)?;
        }
        if self.debug != false {
            os.write_bool(8, self.debug)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CliConfig {
        CliConfig::new()
    }

    fn clear(&mut self) {
        self.files.clear();
        self.output.clear();
        self.overrides.clear();
        self.path_selector.clear();
        self.strict_range_check = false;
        self.disable_none = false;
        self.verbose = 0;
        self.debug = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CliConfig {
        static instance: CliConfig = CliConfig {
            files: ::std::vec::Vec::new(),
            output: ::std::string::String::new(),
            overrides: ::std::vec::Vec::new(),
            path_selector: ::std::vec::Vec::new(),
            strict_range_check: false,
            disable_none: false,
            verbose: 0,
            debug: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CliConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CliConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CliConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CliConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.KeyValuePair)
pub struct KeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.KeyValuePair.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KeyValuePair.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.KeyValuePair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValuePair {
    fn default() -> &'a KeyValuePair {
        <KeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl KeyValuePair {
    pub fn new() -> KeyValuePair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KeyValuePair| { &m.key },
            |m: &mut KeyValuePair| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KeyValuePair| { &m.value },
            |m: &mut KeyValuePair| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValuePair>(
            "KeyValuePair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValuePair {
    const NAME: &'static str = "KeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValuePair {
        KeyValuePair::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValuePair {
        static instance: KeyValuePair = KeyValuePair {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValuePair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValuePair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValuePair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.KclType)
pub struct KclType {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.KclType.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclType.union_types)
    pub union_types: ::std::vec::Vec<KclType>,
    // @@protoc_insertion_point(field:gpyrpc.KclType.default)
    pub default: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclType.schema_name)
    pub schema_name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclType.schema_doc)
    pub schema_doc: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.KclType.properties)
    pub properties: ::std::collections::HashMap<::std::string::String, KclType>,
    // @@protoc_insertion_point(field:gpyrpc.KclType.required)
    pub required: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.KclType.key)
    pub key: ::protobuf::MessageField<KclType>,
    // @@protoc_insertion_point(field:gpyrpc.KclType.item)
    pub item: ::protobuf::MessageField<KclType>,
    // @@protoc_insertion_point(field:gpyrpc.KclType.line)
    pub line: i32,
    // @@protoc_insertion_point(field:gpyrpc.KclType.decorators)
    pub decorators: ::std::vec::Vec<Decorator>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.KclType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KclType {
    fn default() -> &'a KclType {
        <KclType as ::protobuf::Message>::default_instance()
    }
}

impl KclType {
    pub fn new() -> KclType {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &KclType| { &m.type_ },
            |m: &mut KclType| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "union_types",
            |m: &KclType| { &m.union_types },
            |m: &mut KclType| { &mut m.union_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "default",
            |m: &KclType| { &m.default },
            |m: &mut KclType| { &mut m.default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_name",
            |m: &KclType| { &m.schema_name },
            |m: &mut KclType| { &mut m.schema_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_doc",
            |m: &KclType| { &m.schema_doc },
            |m: &mut KclType| { &mut m.schema_doc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties",
            |m: &KclType| { &m.properties },
            |m: &mut KclType| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required",
            |m: &KclType| { &m.required },
            |m: &mut KclType| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KclType>(
            "key",
            |m: &KclType| { &m.key },
            |m: &mut KclType| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KclType>(
            "item",
            |m: &KclType| { &m.item },
            |m: &mut KclType| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "line",
            |m: &KclType| { &m.line },
            |m: &mut KclType| { &mut m.line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "decorators",
            |m: &KclType| { &m.decorators },
            |m: &mut KclType| { &mut m.decorators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KclType>(
            "KclType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KclType {
    const NAME: &'static str = "KclType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.union_types.push(is.read_message()?);
                },
                26 => {
                    self.default = is.read_string()?;
                },
                34 => {
                    self.schema_name = is.read_string()?;
                },
                42 => {
                    self.schema_doc = is.read_string()?;
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                58 => {
                    self.required.push(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item)?;
                },
                80 => {
                    self.line = is.read_int32()?;
                },
                90 => {
                    self.decorators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        for value in &self.union_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.default.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default);
        }
        if !self.schema_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.schema_name);
        }
        if !self.schema_doc.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.schema_doc);
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.required {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.line != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.line);
        }
        for value in &self.decorators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        for v in &self.union_types {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.default.is_empty() {
            os.write_string(3, &self.default)?;
        }
        if !self.schema_name.is_empty() {
            os.write_string(4, &self.schema_name)?;
        }
        if !self.schema_doc.is_empty() {
            os.write_string(5, &self.schema_doc)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.required {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.line != 0 {
            os.write_int32(10, self.line)?;
        }
        for v in &self.decorators {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KclType {
        KclType::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.union_types.clear();
        self.default.clear();
        self.schema_name.clear();
        self.schema_doc.clear();
        self.properties.clear();
        self.required.clear();
        self.key.clear();
        self.item.clear();
        self.line = 0;
        self.decorators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KclType {
        static instance: ::protobuf::rt::Lazy<KclType> = ::protobuf::rt::Lazy::new();
        instance.get(KclType::new)
    }
}

impl ::protobuf::MessageFull for KclType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KclType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KclType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KclType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gpyrpc.Decorator)
pub struct Decorator {
    // message fields
    // @@protoc_insertion_point(field:gpyrpc.Decorator.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:gpyrpc.Decorator.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:gpyrpc.Decorator.keywords)
    pub keywords: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:gpyrpc.Decorator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Decorator {
    fn default() -> &'a Decorator {
        <Decorator as ::protobuf::Message>::default_instance()
    }
}

impl Decorator {
    pub fn new() -> Decorator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Decorator| { &m.name },
            |m: &mut Decorator| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &Decorator| { &m.arguments },
            |m: &mut Decorator| { &mut m.arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "keywords",
            |m: &Decorator| { &m.keywords },
            |m: &mut Decorator| { &mut m.keywords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Decorator>(
            "Decorator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Decorator {
    const NAME: &'static str = "Decorator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.arguments.push(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.keywords.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for (k, v) in &self.keywords {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.arguments {
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.keywords {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Decorator {
        Decorator::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.arguments.clear();
        self.keywords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Decorator {
        static instance: ::protobuf::rt::Lazy<Decorator> = ::protobuf::rt::Lazy::new();
        instance.get(Decorator::new)
    }
}

impl ::protobuf::MessageFull for Decorator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Decorator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Decorator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decorator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cgpyrpc.proto\x12\x06gpyrpc\x1a\x19google/protobuf/any.proto\x1a\
    \x20google/protobuf/descriptor.proto\"6\n\nCmdArgSpec\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue\"\x83\x01\n\x0fCmdOverrideSpec\x12\x18\n\x07pkgpath\x18\x01\x20\x01\
    (\tR\x07pkgpath\x12\x1d\n\nfield_path\x18\x02\x20\x01(\tR\tfieldPath\x12\
    \x1f\n\x0bfield_value\x18\x03\x20\x01(\tR\nfieldValue\x12\x16\n\x06actio\
    n\x18\x04\x20\x01(\tR\x06action\"}\n\x0cRestResponse\x12,\n\x06result\
    \x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x06result\x12\x14\n\x05e\
    rror\x18\x02\x20\x01(\tR\x05error\x12)\n\x07kcl_err\x18\x03\x20\x01(\x0b\
    2\x10.gpyrpc.KclErrorR\x06kclErr\"\x7f\n\x08KclError\x12\x16\n\x06ewcode\
    \x18\x01\x20\x01(\tR\x06ewcode\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04\
    name\x12\x10\n\x03msg\x18\x03\x20\x01(\tR\x03msg\x125\n\x0berror_infos\
    \x18\x04\x20\x03(\x0b2\x14.gpyrpc.KclErrorInfoR\nerrorInfos\"\xab\x01\n\
    \x0cKclErrorInfo\x12\x1b\n\terr_level\x18\x01\x20\x01(\tR\x08errLevel\
    \x12\x17\n\x07arg_msg\x18\x02\x20\x01(\tR\x06argMsg\x12\x1a\n\x08filenam\
    e\x18\x03\x20\x01(\tR\x08filename\x12\x19\n\x08src_code\x18\x04\x20\x01(\
    \tR\x07srcCode\x12\x17\n\x07line_no\x18\x05\x20\x01(\tR\x06lineNo\x12\
    \x15\n\x06col_no\x18\x06\x20\x01(\tR\x05colNo\"!\n\tPing_Args\x12\x14\n\
    \x05value\x18\x01\x20\x01(\tR\x05value\"#\n\x0bPing_Result\x12\x14\n\x05\
    value\x18\x01\x20\x01(\tR\x05value\"\x11\n\x0fListMethod_Args\"=\n\x11Li\
    stMethod_Result\x12(\n\x10method_name_list\x18\x01\x20\x03(\tR\x0emethod\
    NameList\"\x80\x01\n\x17ParseFile_LarkTree_Args\x12\x1a\n\x08filename\
    \x18\x01\x20\x01(\tR\x08filename\x12\x1f\n\x0bsource_code\x18\x02\x20\
    \x01(\tR\nsourceCode\x12(\n\x10ignore_file_line\x18\x03\x20\x01(\x08R\
    \x0eignoreFileLine\"A\n\x19ParseFile_LarkTree_Result\x12$\n\x0elark_tree\
    _json\x18\x01\x20\x01(\tR\x0clarkTreeJson\"Q\n\x12ParseFile_AST_Args\x12\
    \x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x1f\n\x0bsource_c\
    ode\x18\x02\x20\x01(\tR\nsourceCode\"1\n\x14ParseFile_AST_Result\x12\x19\
    \n\x08ast_json\x18\x01\x20\x01(\tR\x07astJson\"?\n\x15ParseProgram_AST_A\
    rgs\x12&\n\x0fk_filename_list\x18\x01\x20\x03(\tR\rkFilenameList\"4\n\
    \x17ParseProgram_AST_Result\x12\x19\n\x08ast_json\x18\x01\x20\x01(\tR\
    \x07astJson\"\x89\x04\n\x10ExecProgram_Args\x12\x19\n\x08work_dir\x18\
    \x01\x20\x01(\tR\x07workDir\x12&\n\x0fk_filename_list\x18\x02\x20\x03(\t\
    R\rkFilenameList\x12\x1e\n\x0bk_code_list\x18\x03\x20\x03(\tR\tkCodeList\
    \x12&\n\x04args\x18\x04\x20\x03(\x0b2\x12.gpyrpc.CmdArgSpecR\x04args\x12\
    5\n\toverrides\x18\x05\x20\x03(\x0b2\x17.gpyrpc.CmdOverrideSpecR\toverri\
    des\x12.\n\x13disable_yaml_result\x18\x06\x20\x01(\x08R\x11disableYamlRe\
    sult\x12,\n\x12print_override_ast\x18\x07\x20\x01(\x08R\x10printOverride\
    Ast\x12,\n\x12strict_range_check\x18\x08\x20\x01(\x08R\x10strictRangeChe\
    ck\x12!\n\x0cdisable_none\x18\t\x20\x01(\x08R\x0bdisableNone\x12\x18\n\
    \x07verbose\x18\n\x20\x01(\x05R\x07verbose\x12\x14\n\x05debug\x18\x0b\
    \x20\x01(\x05R\x05debug\x12\x1b\n\tsort_keys\x18\x0c\x20\x01(\x08R\x08so\
    rtKeys\x127\n\x18include_schema_type_path\x18\r\x20\x01(\x08R\x15include\
    SchemaTypePath\"y\n\x12ExecProgram_Result\x12\x1f\n\x0bjson_result\x18\
    \x01\x20\x01(\tR\njsonResult\x12\x1f\n\x0byaml_result\x18\x02\x20\x01(\t\
    R\nyamlResult\x12!\n\x0cescaped_time\x18e\x20\x01(\tR\x0bescapedTime\"3\
    \n\x10ResetPlugin_Args\x12\x1f\n\x0bplugin_root\x18\x01\x20\x01(\tR\nplu\
    ginRoot\"\x14\n\x12ResetPlugin_Result\")\n\x0fFormatCode_Args\x12\x16\n\
    \x06source\x18\x01\x20\x01(\tR\x06source\"1\n\x11FormatCode_Result\x12\
    \x1c\n\tformatted\x18\x01\x20\x01(\x0cR\tformatted\"%\n\x0fFormatPath_Ar\
    gs\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"7\n\x11FormatPath_Resu\
    lt\x12\"\n\x0cchangedPaths\x18\x01\x20\x03(\tR\x0cchangedPaths\"#\n\rLin\
    tPath_Args\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"+\n\x0fLintPat\
    h_Result\x12\x18\n\x07results\x18\x01\x20\x03(\tR\x07results\"`\n\x11Ove\
    rrideFile_Args\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\x12\x14\n\
    \x05specs\x18\x02\x20\x03(\tR\x05specs\x12!\n\x0cimport_paths\x18\x03\
    \x20\x03(\tR\x0bimportPaths\"-\n\x13OverrideFile_Result\x12\x16\n\x06res\
    ult\x18\x01\x20\x01(\x08R\x06result\"#\n\rEvalCode_Args\x12\x12\n\x04cod\
    e\x18\x01\x20\x01(\tR\x04code\"2\n\x0fEvalCode_Result\x12\x1f\n\x0bjson_\
    result\x18\x02\x20\x01(\tR\njsonResult\"&\n\x10ResolveCode_Args\x12\x12\
    \n\x04code\x18\x01\x20\x01(\tR\x04code\".\n\x12ResolveCode_Result\x12\
    \x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"]\n\x12GetSchemaType\
    _Args\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\x12\x12\n\x04code\
    \x18\x02\x20\x01(\tR\x04code\x12\x1f\n\x0bschema_name\x18\x03\x20\x01(\t\
    R\nschemaName\"Q\n\x14GetSchemaType_Result\x129\n\x10schema_type_list\
    \x18\x01\x20\x03(\x0b2\x0f.gpyrpc.KclTypeR\x0eschemaTypeList\"\x92\x01\n\
    \x11ValidateCode_Args\x12\x12\n\x04data\x18\x01\x20\x01(\tR\x04data\x12\
    \x12\n\x04code\x18\x02\x20\x01(\tR\x04code\x12\x16\n\x06schema\x18\x03\
    \x20\x01(\tR\x06schema\x12%\n\x0eattribute_name\x18\x04\x20\x01(\tR\ratt\
    ributeName\x12\x16\n\x06format\x18\x05\x20\x01(\tR\x06format\"P\n\x13Val\
    idateCode_Result\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\
    \x12\x1f\n\x0berr_message\x18\x02\x20\x01(\tR\nerrMessage\"9\n\x0bCodeSn\
    ippet\x12\x16\n\x06schema\x18\x01\x20\x01(\tR\x06schema\x12\x12\n\x04rul\
    e\x18\x02\x20\x01(\tR\x04rule\"J\n\x0fSpliceCode_Args\x127\n\x0ccodeSnip\
    pets\x18\x01\x20\x03(\x0b2\x13.gpyrpc.CodeSnippetR\x0ccodeSnippets\"3\n\
    \x11SpliceCode_Result\x12\x1e\n\nspliceCode\x18\x01\x20\x01(\tR\nspliceC\
    ode\"R\n\x08Position\x12\x12\n\x04line\x18\x01\x20\x01(\x03R\x04line\x12\
    \x16\n\x06column\x18\x02\x20\x01(\x03R\x06column\x12\x1a\n\x08filename\
    \x18\x03\x20\x01(\tR\x08filename\"[\n\rComplete_Args\x12\"\n\x03pos\x18\
    \x01\x20\x01(\x0b2\x10.gpyrpc.PositionR\x03pos\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x12\n\x04code\x18\x03\x20\x01(\tR\x04code\"7\n\
    \x0fComplete_Result\x12$\n\rcompleteItems\x18\x01\x20\x01(\tR\rcompleteI\
    tems\"F\n\x0cGoToDef_Args\x12\"\n\x03pos\x18\x01\x20\x01(\x0b2\x10.gpyrp\
    c.PositionR\x03pos\x12\x12\n\x04code\x18\x02\x20\x01(\tR\x04code\".\n\
    \x0eGoToDef_Result\x12\x1c\n\tlocations\x18\x01\x20\x01(\tR\tlocations\"\
    =\n\x13DocumentSymbol_Args\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\
    \x12\x12\n\x04code\x18\x02\x20\x01(\tR\x04code\"/\n\x15DocumentSymbol_Re\
    sult\x12\x16\n\x06symbol\x18\x01\x20\x01(\tR\x06symbol\"D\n\nHover_Args\
    \x12\"\n\x03pos\x18\x01\x20\x01(\x0b2\x10.gpyrpc.PositionR\x03pos\x12\
    \x12\n\x04code\x18\x02\x20\x01(\tR\x04code\"0\n\x0cHover_Result\x12\x20\
    \n\x0bhoverResult\x18\x01\x20\x01(\tR\x0bhoverResult\"\x99\x01\n\x11List\
    DepFiles_Args\x12\x19\n\x08work_dir\x18\x01\x20\x01(\tR\x07workDir\x12\
    \x20\n\x0cuse_abs_path\x18\x02\x20\x01(\x08R\nuseAbsPath\x12\x1f\n\x0bin\
    clude_all\x18\x03\x20\x01(\x08R\nincludeAll\x12&\n\x0fuse_fast_parser\
    \x18\x04\x20\x01(\x08R\ruseFastParser\"_\n\x13ListDepFiles_Result\x12\
    \x18\n\x07pkgroot\x18\x01\x20\x01(\tR\x07pkgroot\x12\x18\n\x07pkgpath\
    \x18\x02\x20\x01(\tR\x07pkgpath\x12\x14\n\x05files\x18\x03\x20\x03(\tR\
    \x05files\"I\n\x16ListUpStreamFiles_Args\x12\x19\n\x08work_dir\x18\x01\
    \x20\x01(\tR\x07workDir\x12\x14\n\x05files\x18\x02\x20\x03(\tR\x05files\
    \"0\n\x18ListUpStreamFiles_Result\x12\x14\n\x05files\x18\x01\x20\x03(\tR\
    \x05files\"p\n\x18ListDownStreamFiles_Args\x12\x19\n\x08work_dir\x18\x01\
    \x20\x01(\tR\x07workDir\x12\x14\n\x05files\x18\x02\x20\x03(\tR\x05files\
    \x12#\n\rchanged_paths\x18\x03\x20\x03(\tR\x0cchangedPaths\"2\n\x1aListD\
    ownStreamFiles_Result\x12\x14\n\x05files\x18\x01\x20\x03(\tR\x05files\"I\
    \n\x16LoadSettingsFiles_Args\x12\x19\n\x08work_dir\x18\x01\x20\x01(\tR\
    \x07workDir\x12\x14\n\x05files\x18\x02\x20\x03(\tR\x05files\"\x8c\x01\n\
    \x18LoadSettingsFiles_Result\x129\n\x0fkcl_cli_configs\x18\x01\x20\x01(\
    \x0b2\x11.gpyrpc.CliConfigR\rkclCliConfigs\x125\n\x0bkcl_options\x18\x02\
    \x20\x03(\x0b2\x14.gpyrpc.KeyValuePairR\nkclOptions\"\xfd\x01\n\tCliConf\
    ig\x12\x14\n\x05files\x18\x01\x20\x03(\tR\x05files\x12\x16\n\x06output\
    \x18\x02\x20\x01(\tR\x06output\x12\x1c\n\toverrides\x18\x03\x20\x03(\tR\
    \toverrides\x12#\n\rpath_selector\x18\x04\x20\x03(\tR\x0cpathSelector\
    \x12,\n\x12strict_range_check\x18\x05\x20\x01(\x08R\x10strictRangeCheck\
    \x12!\n\x0cdisable_none\x18\x06\x20\x01(\x08R\x0bdisableNone\x12\x18\n\
    \x07verbose\x18\x07\x20\x01(\x03R\x07verbose\x12\x14\n\x05debug\x18\x08\
    \x20\x01(\x08R\x05debug\"6\n\x0cKeyValuePair\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\
    \xe5\x03\n\x07KclType\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x120\
    \n\x0bunion_types\x18\x02\x20\x03(\x0b2\x0f.gpyrpc.KclTypeR\nunionTypes\
    \x12\x18\n\x07default\x18\x03\x20\x01(\tR\x07default\x12\x1f\n\x0bschema\
    _name\x18\x04\x20\x01(\tR\nschemaName\x12\x1d\n\nschema_doc\x18\x05\x20\
    \x01(\tR\tschemaDoc\x12?\n\nproperties\x18\x06\x20\x03(\x0b2\x1f.gpyrpc.\
    KclType.PropertiesEntryR\nproperties\x12\x1a\n\x08required\x18\x07\x20\
    \x03(\tR\x08required\x12!\n\x03key\x18\x08\x20\x01(\x0b2\x0f.gpyrpc.KclT\
    ypeR\x03key\x12#\n\x04item\x18\t\x20\x01(\x0b2\x0f.gpyrpc.KclTypeR\x04it\
    em\x12\x12\n\x04line\x18\n\x20\x01(\x05R\x04line\x121\n\ndecorators\x18\
    \x0b\x20\x03(\x0b2\x11.gpyrpc.DecoratorR\ndecorators\x1aN\n\x0fPropertie\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12%\n\x05value\x18\
    \x02\x20\x01(\x0b2\x0f.gpyrpc.KclTypeR\x05value:\x028\x01\"\xb7\x01\n\tD\
    ecorator\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1c\n\targume\
    nts\x18\x02\x20\x03(\tR\targuments\x12;\n\x08keywords\x18\x03\x20\x03(\
    \x0b2\x1f.gpyrpc.Decorator.KeywordsEntryR\x08keywords\x1a;\n\rKeywordsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x012\x82\x01\n\x0eBuiltinService\x12.\n\
    \x04Ping\x12\x11.gpyrpc.Ping_Args\x1a\x13.gpyrpc.Ping_Result\x12@\n\nLis\
    tMethod\x12\x17.gpyrpc.ListMethod_Args\x1a\x19.gpyrpc.ListMethod_Result2\
    \xe8\x0c\n\x0cKclvmService\x12.\n\x04Ping\x12\x11.gpyrpc.Ping_Args\x1a\
    \x13.gpyrpc.Ping_Result\x12X\n\x12ParseFile_LarkTree\x12\x1f.gpyrpc.Pars\
    eFile_LarkTree_Args\x1a!.gpyrpc.ParseFile_LarkTree_Result\x12I\n\rParseF\
    ile_AST\x12\x1a.gpyrpc.ParseFile_AST_Args\x1a\x1c.gpyrpc.ParseFile_AST_R\
    esult\x12R\n\x10ParseProgram_AST\x12\x1d.gpyrpc.ParseProgram_AST_Args\
    \x1a\x1f.gpyrpc.ParseProgram_AST_Result\x12C\n\x0bExecProgram\x12\x18.gp\
    yrpc.ExecProgram_Args\x1a\x1a.gpyrpc.ExecProgram_Result\x12C\n\x0bResetP\
    lugin\x12\x18.gpyrpc.ResetPlugin_Args\x1a\x1a.gpyrpc.ResetPlugin_Result\
    \x12@\n\nFormatCode\x12\x17.gpyrpc.FormatCode_Args\x1a\x19.gpyrpc.Format\
    Code_Result\x12@\n\nFormatPath\x12\x17.gpyrpc.FormatPath_Args\x1a\x19.gp\
    yrpc.FormatPath_Result\x12:\n\x08LintPath\x12\x15.gpyrpc.LintPath_Args\
    \x1a\x17.gpyrpc.LintPath_Result\x12F\n\x0cOverrideFile\x12\x19.gpyrpc.Ov\
    errideFile_Args\x1a\x1b.gpyrpc.OverrideFile_Result\x12:\n\x08EvalCode\
    \x12\x15.gpyrpc.EvalCode_Args\x1a\x17.gpyrpc.EvalCode_Result\x12C\n\x0bR\
    esolveCode\x12\x18.gpyrpc.ResolveCode_Args\x1a\x1a.gpyrpc.ResolveCode_Re\
    sult\x12I\n\rGetSchemaType\x12\x1a.gpyrpc.GetSchemaType_Args\x1a\x1c.gpy\
    rpc.GetSchemaType_Result\x12F\n\x0cValidateCode\x12\x19.gpyrpc.ValidateC\
    ode_Args\x1a\x1b.gpyrpc.ValidateCode_Result\x12@\n\nSpliceCode\x12\x17.g\
    pyrpc.SpliceCode_Args\x1a\x19.gpyrpc.SpliceCode_Result\x12:\n\x08Complet\
    e\x12\x15.gpyrpc.Complete_Args\x1a\x17.gpyrpc.Complete_Result\x127\n\x07\
    GoToDef\x12\x14.gpyrpc.GoToDef_Args\x1a\x16.gpyrpc.GoToDef_Result\x12L\n\
    \x0eDocumentSymbol\x12\x1b.gpyrpc.DocumentSymbol_Args\x1a\x1d.gpyrpc.Doc\
    umentSymbol_Result\x121\n\x05Hover\x12\x12.gpyrpc.Hover_Args\x1a\x14.gpy\
    rpc.Hover_Result\x12F\n\x0cListDepFiles\x12\x19.gpyrpc.ListDepFiles_Args\
    \x1a\x1b.gpyrpc.ListDepFiles_Result\x12U\n\x11ListUpStreamFiles\x12\x1e.\
    gpyrpc.ListUpStreamFiles_Args\x1a\x20.gpyrpc.ListUpStreamFiles_Result\
    \x12[\n\x13ListDownStreamFiles\x12\x20.gpyrpc.ListDownStreamFiles_Args\
    \x1a\".gpyrpc.ListDownStreamFiles_Result\x12U\n\x11LoadSettingsFiles\x12\
    \x1e.gpyrpc.LoadSettingsFiles_Args\x1a\x20.gpyrpc.LoadSettingsFiles_Resu\
    ltB0Z.kusionstack.io/kclvm-go/pkg/spec/gpyrpc;gpyrpcb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(59);
            messages.push(CmdArgSpec::generated_message_descriptor_data());
            messages.push(CmdOverrideSpec::generated_message_descriptor_data());
            messages.push(RestResponse::generated_message_descriptor_data());
            messages.push(KclError::generated_message_descriptor_data());
            messages.push(KclErrorInfo::generated_message_descriptor_data());
            messages.push(Ping_Args::generated_message_descriptor_data());
            messages.push(Ping_Result::generated_message_descriptor_data());
            messages.push(ListMethod_Args::generated_message_descriptor_data());
            messages.push(ListMethod_Result::generated_message_descriptor_data());
            messages.push(ParseFile_LarkTree_Args::generated_message_descriptor_data());
            messages.push(ParseFile_LarkTree_Result::generated_message_descriptor_data());
            messages.push(ParseFile_AST_Args::generated_message_descriptor_data());
            messages.push(ParseFile_AST_Result::generated_message_descriptor_data());
            messages.push(ParseProgram_AST_Args::generated_message_descriptor_data());
            messages.push(ParseProgram_AST_Result::generated_message_descriptor_data());
            messages.push(ExecProgram_Args::generated_message_descriptor_data());
            messages.push(ExecProgram_Result::generated_message_descriptor_data());
            messages.push(ResetPlugin_Args::generated_message_descriptor_data());
            messages.push(ResetPlugin_Result::generated_message_descriptor_data());
            messages.push(FormatCode_Args::generated_message_descriptor_data());
            messages.push(FormatCode_Result::generated_message_descriptor_data());
            messages.push(FormatPath_Args::generated_message_descriptor_data());
            messages.push(FormatPath_Result::generated_message_descriptor_data());
            messages.push(LintPath_Args::generated_message_descriptor_data());
            messages.push(LintPath_Result::generated_message_descriptor_data());
            messages.push(OverrideFile_Args::generated_message_descriptor_data());
            messages.push(OverrideFile_Result::generated_message_descriptor_data());
            messages.push(EvalCode_Args::generated_message_descriptor_data());
            messages.push(EvalCode_Result::generated_message_descriptor_data());
            messages.push(ResolveCode_Args::generated_message_descriptor_data());
            messages.push(ResolveCode_Result::generated_message_descriptor_data());
            messages.push(GetSchemaType_Args::generated_message_descriptor_data());
            messages.push(GetSchemaType_Result::generated_message_descriptor_data());
            messages.push(ValidateCode_Args::generated_message_descriptor_data());
            messages.push(ValidateCode_Result::generated_message_descriptor_data());
            messages.push(CodeSnippet::generated_message_descriptor_data());
            messages.push(SpliceCode_Args::generated_message_descriptor_data());
            messages.push(SpliceCode_Result::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(Complete_Args::generated_message_descriptor_data());
            messages.push(Complete_Result::generated_message_descriptor_data());
            messages.push(GoToDef_Args::generated_message_descriptor_data());
            messages.push(GoToDef_Result::generated_message_descriptor_data());
            messages.push(DocumentSymbol_Args::generated_message_descriptor_data());
            messages.push(DocumentSymbol_Result::generated_message_descriptor_data());
            messages.push(Hover_Args::generated_message_descriptor_data());
            messages.push(Hover_Result::generated_message_descriptor_data());
            messages.push(ListDepFiles_Args::generated_message_descriptor_data());
            messages.push(ListDepFiles_Result::generated_message_descriptor_data());
            messages.push(ListUpStreamFiles_Args::generated_message_descriptor_data());
            messages.push(ListUpStreamFiles_Result::generated_message_descriptor_data());
            messages.push(ListDownStreamFiles_Args::generated_message_descriptor_data());
            messages.push(ListDownStreamFiles_Result::generated_message_descriptor_data());
            messages.push(LoadSettingsFiles_Args::generated_message_descriptor_data());
            messages.push(LoadSettingsFiles_Result::generated_message_descriptor_data());
            messages.push(CliConfig::generated_message_descriptor_data());
            messages.push(KeyValuePair::generated_message_descriptor_data());
            messages.push(KclType::generated_message_descriptor_data());
            messages.push(Decorator::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
